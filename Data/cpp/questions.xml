<Root total_elements="70">
	<Element reference_id="1">
	<Explanation>
The templated function will be instantiated as void f(int&#x26;), which is a better match than f(const int&#x26;).
	</Explanation>
	<Hint>
What will the signature of the instantiated template function be? Which will then be the best match?
	</Hint>
	<Question>
According to the C++11 standard, what is output of the following code?
	</Question>
	<Options>
		<option value="The program is guaranteed to output"/>
		<option value="The program has a compilation error"/>
		<option value="The program is unspecified/implementation defined"/>
		<option value="The program is undefined"/>
	</Options>
	<Code>
<![CDATA[
<pre>
#include &#x3C;iostream&#x3E;<br>
template &#x3C;class T&#x3E; <br>
void f( T &#x26;i )<br>
{<br>
&#x9;std::cout &#x3C;&#x3C; 1;<br>
}<br>
template &#x3C;&#x3E; <br>
void f( const int &#x26;i )<br>
{<br>
&#x9;std::cout &#x3C;&#x3C; 2;<br>
}<br>
int main()<br>
{ <br>
&#x9;int i = 42; <br>
&#x9;f(i);<br>
}<br>
</pre>
]]>
	</Code>
	<Level value="Intermediate"/>
	</Element>
	<Element reference_id="2">
	<Explanation>
A string literal is not a std::string, but a const char[] . If the compiler was to choose f(const std::string&#x26;), it would have to go through a user defined conversion and create a temporary std::string. Instead, it prefers f(const void*), which requires no user defined conversion.
	</Explanation>
	<Options>
		<option value="The program is guaranteed to output"/>
		<option value="The program has a compilation error"/>
		<option value="The program is unspecified/implementation defined"/>
		<option value="The program is undefined"/>
	</Options>
	<Question>
According to the C++11 standard, what is output of the following code?
	</Question>
	<Code>
<![CDATA[
<pre>
#include &#x3C;iostream&#x3E;<br>
#include &#x3C;string&#x3E;<br>
void f( const std::string &#x26; )<br>
{<br>
&#x9;std::cout &#x3C;&#x3C; 1;<br>
}<br>
void f( const void * )<br>
{<br>
&#x9;std::cout &#x3C;&#x3C; 2;<br>
}<br>
int main()<br>
{<br>
&#x9;f(&#x22;foo&#x22;);<br>
&#x9;const char *bar = &#x22;bar&#x22;; <br>
&#x9;f(bar);<br>
}<br>
</pre>
]]>
	</Code>
	<Level value="Intermediate"/>
	<Hint>
What is the type of a string literal? Does the compiler prefer standard or user defined conversions?
	</Hint>
	</Element>
	<Element reference_id="3">
	<Explanation>
This overload is ambiguous. Why? There are two viable functions for the call f(-2.5). For the compiler to select one, one of them needs to be better than the other, or the program is ill-formed. In our case, they are equally good, making the program ill-formed. According to &#xA7;13.3.3 in the standard, a viable one-argument function is better than another if the conversion sequence for the argument is better. So why isn&#x27;t the int conversion sequence better than the unsigned conversion sequence, given that the double is signed? All conversions are given a rank, and both &#x22;double =&#x3E; int&#x22; and &#x22;double =&#x3E; unsigned int&#x22; are of type &#x22;floating-integral conversion&#x22;, which has rank &#x22;conversion&#x22;. See Table 12 in the standard and &#xA7;4.9. Since they have the same rank, no conversion is better than the other, and the program is ill-formed.
	</Explanation>
	<Options>
		<option value="The program is guaranteed to output"/>
		<option value="The program has a compilation error"/>
		<option value="The program is unspecified/implementation defined"/>
		<option value="The program is undefined"/>
	</Options>
	<Question>
According to the C++11 standard, what is output of the following code?
	</Question>
	<Code>
<![CDATA[
<pre>
#include &#x3C;iostream&#x3E;<br>
void f(int)<br>
{ <br>
&#x9;std::cout &#x3C;&#x3C; 1; <br>
}<br>
 <br>
void f( unsigned )<br>
{ <br>
&#x9;std::cout &#x3C;&#x3C; 2;<br>
} <br>
int main()<br>
{<br>
&#x9;f(-2.5);<br>
}<br>
</pre>
]]>
	</Code>
	<Level value="Beginner"/>
	<Hint>
What are the ranks of the conversions &#x22;double =&#x3E; int&#x22; and &#x22;double =&#x3E; unsigned int&#x22;? Is one better than the other?
	</Hint>
	</Element>
	<Element reference_id="4">
	<Explanation>
The type of a floating point literal is double.
	</Explanation>
	<Options>
		<option value="The program is guaranteed to output"/>
		<option value="The program has a compilation error"/>
		<option value="The program is unspecified/implementation defined"/>
		<option value="The program is undefined"/>
	</Options>
	<Question>
According to the C++11 standard, what is output of the following code?
	</Question>
	<Code>
<![CDATA[
<pre>
#include &#x3C;iostream&#x3E;<br>
void f( float )<br>
{<br>
&#x9;std::cout &#x3C;&#x3C; 1;<br>
}<br>
void f( double )<br>
{<br>
&#x9;std::cout &#x3C;&#x3C; 2;<br>
}<br>
int main()<br>
{<br>
&#x9;f( 2.5 );<br>
&#x9;f( 2.5f );<br>
}<br>
</pre>
]]>
	</Code>
	<Level value="Beginner"/>
	<Hint>
What is the type of a floating point literal?
	</Hint>
	</Element>
	<Element reference_id="5">
	<Explanation>
The initialization order of member variables is determined by their order of declaration, not their order in the initialization list.
	</Explanation>
	<Options>
		<option value="The program is guaranteed to output"/>
		<option value="The program has a compilation error"/>
		<option value="The program is unspecified/implementation defined"/>
		<option value="The program is undefined"/>
	</Options>
	<Question>
According to the C++11 standard, what is output of the following code?
	</Question>
	<Code>
<![CDATA[
<pre>
#include &#x3C;iostream&#x3E;<br>
struct A<br>
{<br>
&#x9;A()<br>
&#x9;{ <br>
&#x9;&#x9;std::cout &#x3C;&#x3C; &#x22;A&#x22;; <br>
&#x9;}<br>
};<br>
struct B<br>
{ <br>
&#x9;B()<br>
&#x9;{<br>
&#x9;&#x9;std::cout &#x3C;&#x3C; &#x22;B&#x22;;<br>
&#x9;}<br>
}; <br>
class C<br>
{ <br>
public:<br>
&#x9;C(): a(), b() {} <br>
private: <br>
&#x9;B b; A a; <br>
}; <br>
int main()<br>
{<br>
&#x9;C();<br>
}<br>
</pre>
]]>
	</Code>
	<Level value="Beginner"/>
	<Hint>
What determines the order of member variable initialization?
	</Hint>
	</Element>
	<Element reference_id="6">
	<Explanation>
Whether you post-increment or pre-increment i, its value does not change until after the loop body has executed.
	</Explanation>
	<Options>
		<option value="The program is guaranteed to output"/>
		<option value="The program has a compilation error"/>
		<option value="The program is unspecified/implementation defined"/>
		<option value="The program is undefined"/>
	</Options>
	<Question>
According to the C++11 standard, what is output of the following code?
	</Question>
	<Code>
<![CDATA[
<pre>
#include &#x3C;iostream&#x3E; <br>
int main()<br>
{ <br>
&#x9;for ( int i = 0; i &#x3C; 3; i++ )<br>
&#x9;&#x9;std::cout &#x3C;&#x3C; i; <br>
&#x9;for( int i = 0; i &#x3C; 3; ++i )<br>
&#x9;&#x9;std::cout &#x3C;&#x3C; i;<br>
}<br>
</pre>
]]>
	</Code>
	<Level value="Beginner"/>
	<Hint>
When is i incremented?
	</Hint>
	</Element>
	<Element reference_id="7">
	<Explanation>
As long as A::f() is not virtual, A::f() will always be called, even if the reference or pointer is actually referring to an object of type B.
	</Explanation>
	<Hint>
virtual
	</Hint>
	<Question>
According to the C++11 standard, what is output of the following code?
	</Question>
	<Options>
		<option value="The program is guaranteed to output"/>
		<option value="The program has a compilation error"/>
		<option value="The program is unspecified/implementation defined"/>
		<option value="The program is undefined"/>
	</Options>
	<Code>
<![CDATA[
<pre>
#include &#x3C;iostream&#x3E; <br>
class A<br>
{<br>
public:<br>
&#x9;void f(){<br>
&#x9;&#x9;std::cout &#x3C;&#x3C; &#x22;A&#x22;;<br>
&#x9;}<br>
};<br>
class B: public A<br>
{ <br>
public: <br>
&#x9;void f() <br>
&#x9;{ <br>
&#x9;&#x9;std::cout &#x3C;&#x3C; &#x22;B&#x22;;<br>
&#x9;}<br>
}; <br>
void g( A &#x26;a )<br>
{<br>
&#x9;a.f();<br>
}<br>
int main()<br>
{<br>
&#x9;B b;<br>
&#x9;g( b );<br>
}<br>
</pre>
]]>
	</Code>
	<Level value="Beginner"/>
	</Element>
	<Element reference_id="8">
	<Explanation>
When f() is called with a as both parameters, both arguments refer to the same variable. This is known as aliasing. First, a is set to 3, then a is set to 4, then 4+4 is returned. b is never modified.
	</Explanation>
	<Hint>
Aliasing
	</Hint>
	<Question>
According to the C++11 standard, what is output of the following code?
	</Question>
	<Options>
		<option value="The program is guaranteed to output"/>
		<option value="The program has a compilation error"/>
		<option value="The program is unspecified/implementation defined"/>
		<option value="The program is undefined"/>
	</Options>
	<Code>
<![CDATA[
<pre>
#include &#x3C;iostream&#x3E;<br>
int f( int &#x26;a, int &#x26;b )<br>
{<br>
&#x9;a = 3;<br>
&#x9;b = 4; <br>
&#x9;return a + b;<br>
} <br>
int main()<br>
{<br>
&#x9;int a = 1;<br>
&#x9;int b = 2;<br>
&#x9;int c = f( a, a );<br>
&#x9;std::cout &#x3C;&#x3C; a &#x3C;&#x3C; b &#x3C;&#x3C; c;<br>
}<br>
</pre>
]]>
	</Code>
	<Level value="Beginner"/>
	</Element>
	<Element reference_id="9">
	<Explanation>
Since a has static storage duration and no initializer, it is guaranteed to be zero-initialized. Had a been defined as a local non-static variable inside main(), this would not have happened. Note: int a has static storage duration because it is declared at namespace scope. It does not need to have static in front of it, that would only denote internal linkage.
	</Explanation>
	<Hint>
Is a static? And what do we mean by &#x22;static&#x22; anyway? Think about the difference between static storage duration and external linkage.
	</Hint>
	<Question>
According to the C++11 standard, what is output of the following code?
	</Question>
	<Options>
		<option value="The program is guaranteed to output"/>
		<option value="The program has a compilation error"/>
		<option value="The program is unspecified/implementation defined"/>
		<option value="The program is undefined"/>
	</Options>
	<Code>
<![CDATA[
<pre>
#include &#x3C;iostream&#x3E; <br>
int a;<br>
int main()<br>
{ <br>
&#x9;std::cout &#x3C;&#x3C; a;<br>
}<br>
</pre>
]]>
	</Code>
	<Level value="Beginner"/>
	</Element>
	<Element reference_id="10">
	<Explanation>
Since a is a static local variable, it is automatically initialized to its default value, 0. This would not have happened if we removed the keyword static, making it a non-static local variable.
	</Explanation>
	<Hint>
How are local static variables initialized?
	</Hint>
	<Question>
According to the C++11 standard, what is output of the following code?
	</Question>
	<Options>
		<option value="The program is guaranteed to output"/>
		<option value="The program has a compilation error"/>
		<option value="The program is unspecified/implementation defined"/>
		<option value="The program is undefined"/>
	</Options>
	<Code>
<![CDATA[
<pre>
#include &#x3C;iostream&#x3E; <br>
int main()<br>
{<br>
&#x9;static int a;<br>
&#x9;std::cout &#x3C;&#x3C; a;<br>
}<br>
</pre>
]]>
	</Code>
	<Level value="Beginner"/>
	</Element>
	<Element reference_id="11">
	<Explanation>
&#xA7;3.6.2&#xB6;4 in the standard: &#x22;It is implementation-defined whether the dynamic initialization of a non-local variable with static storage duration is done before the first statement of main. If the initialization is deferred to some point in time after the first statement of main, it shall occur before the first odr-use (3.2) of any function or variable defined in the same translation unit as the variable to be initialized.&#x22; Since A() is not constexpr, the initialization of a is dynamic. There are two possibilities: - a is initialized before main() is called, i.e. before b or c are initialized. - a is not initialized before main(). It is however guaranteed to be initialized before the the use of any function defined in the same translation unit, i.e. before the constructors of b and c are called. Then, b and c are initialized in order. Before main() exits, b and c are destructed in the reverse order of their construction. Then, when main() returns, a is destructed as per &#xA7;3.6.3 in the standard: &#x22;Destructors for initialized objects (...) with static storage duration are called as a result of returning from main.&#x22;
	</Explanation>
	<Options>
		<option value="The program is guaranteed to output"/>
		<option value="The program has a compilation error"/>
		<option value="The program is unspecified/implementation defined"/>
		<option value="The program is undefined"/>
	</Options>
	<Question>
According to the C++11 standard, what is output of the following code?
	</Question>
	<Code>
<![CDATA[
<pre>
#include &#x3C;iostream&#x3E;<br>
class A<br>
{<br>
public: <br>
&#x9;A()<br>
&#x9;{<br>
&#x9;&#x9;std::cout &#x3C;&#x3C; &#x22;a&#x22;;<br>
&#x9;}<br>
&#x9;~A()<br>
&#x9;{<br>
&#x9;&#x9;std::cout &#x3C;&#x3C; &#x22;A&#x22;;<br>
&#x9;}<br>
}; <br>
class B<br>
{<br>
public: <br>
&#x9;B()<br>
&#x9;{<br>
&#x9;&#x9;std::cout &#x3C;&#x3C; &#x22;b&#x22;;<br>
&#x9;}<br>
&#x9;~B()<br>
&#x9;{ <br>
&#x9;&#x9;std::cout &#x3C;&#x3C; &#x22;B&#x22;;<br>
&#x9;}<br>
}; <br>
class C<br>
{<br>
public:<br>
&#x9;C()<br>
&#x9;{<br>
&#x9;&#x9;std::cout &#x3C;&#x3C; &#x22;c&#x22;;<br>
&#x9;}<br>
&#x9;~C()<br>
&#x9;{ <br>
&#x9;&#x9;std::cout &#x3C;&#x3C; &#x22;C&#x22;;<br>
&#x9;}<br>
};<br>
A a; <br>
int main()<br>
{<br>
&#x9;C c;<br>
&#x9;B b;<br>
}<br>
</pre>
]]>
	</Code>
	<Level value="Beginner"/>
	<Hint>
When are non-local static variables initialized? When are local variables initialized? When are they destroyed?
	</Hint>
	</Element>
	<Element reference_id="12">
	<Explanation>
&#xA7;3.6.2&#xB6;4 in the standard: &#x22;It is implementation-defined whether the dynamic initialization of a non-local variable with static storage duration is done before the first statement of main. If the initialization is deferred to some point in time after the first statement of main, it shall occur before the first odr-use (3.2) of any function or variable defined in the same translation unit as the variable to be initialized.&#x22; Since A() is not constexpr, the initialization of a is dynamic. There are two possibilities: - a is initialized before main() is called, i.e. before b is initialized. - a is not initialized before main(). It is however guaranteed to be initialized before the the use of any function defined in the same translation unit, i.e. before the constructor of b is called. When execution reaches B b, it is initialized as normal. Static local variables are initialized the first time control passes through their declaration, so c is initialized next. As main() is exited, its local variable b goes out of scope, and is destroyed. Finally, all static variables are destroyed in reverse order of their initialization, first c, then a.
	</Explanation>
	<Hint>
When are non-local static variables, local static variables and local automatic variables initialized and destroyed? Does it matter if we put static in front of A a?
	</Hint>
	<Question>
According to the C++11 standard, what is output of the following code?
	</Question>
	<Options>
		<option value="The program is guaranteed to output"/>
		<option value="The program has a compilation error"/>
		<option value="The program is unspecified/implementation defined"/>
		<option value="The program is undefined"/>
	</Options>
	<Code>
<![CDATA[
<pre>
#include &#x3C;iostream&#x3E; <br>
class A<br>
{<br>
public:<br>
&#x9;A()<br>
&#x9;{<br>
&#x9;&#x9;std::cout &#x3C;&#x3C; &#x22;a&#x22;;<br>
&#x9;}<br>
&#x9;~A()<br>
&#x9;{<br>
&#x9;&#x9;std::cout &#x3C;&#x3C; &#x22;A&#x22;;<br>
&#x9;}<br>
};<br>
class B<br>
{<br>
public: <br>
&#x9;B()<br>
&#x9;{<br>
&#x9;&#x9;std::cout &#x3C;&#x3C; &#x22;b&#x22;;<br>
&#x9;}<br>
&#x9;~B()<br>
&#x9;{<br>
&#x9;&#x9;std::cout &#x3C;&#x3C; &#x22;B&#x22;; <br>
&#x9;}<br>
};<br>
class C<br>
{<br>
public: <br>
&#x9;C()<br>
&#x9;{<br>
&#x9;&#x9;std::cout &#x3C;&#x3C; &#x22;c&#x22;;<br>
&#x9;}<br>
&#x9;~C()<br>
&#x9;{<br>
&#x9;&#x9;std::cout &#x3C;&#x3C; &#x22;C&#x22;;<br>
&#x9;}<br>
}; <br>
A a;<br>
void foo()<br>
{ <br>
&#x9;static C c;<br>
}<br>
int main()<br>
{<br>
&#x9;B b; foo();<br>
}<br>
</pre>
]]>
	</Code>
	<Level value="Intermediate"/>
	</Element>
	<Element reference_id="13">
	<Explanation>
Static local variables are initialized the first time control passes through their declaration. The first time foo() is called, b is attempted initialized. Its constructor is called, which first constructs all member variables. This means A::A() is called, printing a. A::A() then throws an exception, the constructor is aborted, and neither b or B::a are actually considered constructed. In the catch-block, c is printed, and then foo() is called again. Since b was never initialized the first time, it tries again, this time succeeding, printing ab. When main() exits, the static variable b is destroyed, first calling the destructor printing B, and then destroying member variables, printing A.
	</Explanation>
	<Hint>
When are static local variables initialized? If an exception is thrown in a constructor, is the object considered constructed? Will the destructor be called?
	</Hint>
	<Question>
According to the C++11 standard, what is output of the following code?
	</Question>
	<Options>
		<option value="The program is guaranteed to output"/>
		<option value="The program has a compilation error"/>
		<option value="The program is unspecified/implementation defined"/>
		<option value="The program is undefined"/>
	</Options>
	<Code>
<![CDATA[
<pre>
#include &#x3C;iostream&#x3E;<br>
#include &#x3C;exception&#x3E; <br>
int x = 0;<br>
class A<br>
{<br>
public:<br>
&#x9;A()<br>
&#x9;{<br>
&#x9;&#x9;std::cout &#x3C;&#x3C; &#x27;a&#x27;; <br>
&#x9;&#x9;if ( x++ == 0 )<br>
&#x9;&#x9;{<br>
&#x9;&#x9;&#x9;throw std::exception();<br>
&#x9;&#x9;}<br>
&#x9;}<br>
&#x9;~A()<br>
&#x9;{<br>
&#x9;&#x9;std::cout &#x3C;&#x3C; &#x27;A&#x27;;<br>
&#x9;}<br>
}; <br>
class B<br>
{<br>
&#x9;public: <br>
&#x9;B()<br>
&#x9;{<br>
&#x9;&#x9;std::cout &#x3C;&#x3C; &#x27;b&#x27;;<br>
&#x9;}<br>
&#x9;~B()<br>
&#x9;{<br>
&#x9;&#x9;std::cout &#x3C;&#x3C; &#x27;B&#x27;;<br>
&#x9;}<br>
&#x9;<br>
&#x9;A a;<br>
};<br>
void foo()<br>
{<br>
&#x9;static B b;<br>
}<br>
int main()<br>
{<br>
&#x9;try<br>
&#x9;{<br>
&#x9;&#x9;foo();<br>
&#x9;}<br>
&#x9;catch ( std::exception &#x26; )<br>
&#x9;{<br>
&#x9;&#x9;std::cout &#x3C;&#x3C; &#x27;c&#x27;;<br>
&#x9;&#x9;foo();<br>
&#x9;}<br>
}<br>
</pre>
]]>
	</Code>
	<Level value="Hard"/>
	</Element>
	<Element reference_id="14">
	<Explanation>
Member variables are initialized before the constructor is called. The destructor is called before member variables are destroyed.
	</Explanation>
	<Hint>
When are member variables initialized and destroyed?
	</Hint>
	<Question>
According to the C++11 standard, what is output of the following code?
	</Question>
	<Options>
		<option value="The program is guaranteed to output"/>
		<option value="The program has a compilation error"/>
		<option value="The program is unspecified/implementation defined"/>
		<option value="The program is undefined"/>
	</Options>
	<Code>
<![CDATA[
<pre>
#include &#x3C;iostream&#x3E;<br>
class A<br>
{<br>
public:<br>
&#x9;A()<br>
&#x9;{<br>
&#x9;&#x9;std::cout &#x3C;&#x3C; &#x27;a&#x27;;<br>
&#x9;}<br>
&#x9;~A()<br>
&#x9;{<br>
&#x9;&#x9;std::cout &#x3C;&#x3C; &#x27;A&#x27;;<br>
&#x9;}<br>
}; <br>
class B<br>
{<br>
public: <br>
&#x9;B()<br>
&#x9;{ <br>
&#x9;&#x9;std::cout &#x3C;&#x3C; &#x27;b&#x27;;<br>
&#x9;}<br>
&#x9;~B()<br>
&#x9;{<br>
&#x9;&#x9;std::cout &#x3C;&#x3C; &#x27;B&#x27;;<br>
&#x9;}<br>
&#x9;A a;<br>
}; <br>
int main()<br>
{<br>
&#x9;B b;<br>
}<br>
</pre>
]]>
	</Code>
	<Level value="Beginner"/>
	</Element>
	<Element reference_id="15">
	<Explanation>
The base class constructor is called before the inherited constructor. The inherited destructor is called before the base class destructor.
	</Explanation>
	<Hint>
In what order are the base and derived constructors and destructors called?
	</Hint>
	<Question>
According to the C++11 standard, what is output of the following code?
	</Question>
	<Options>
		<option value="The program is guaranteed to output"/>
		<option value="The program has a compilation error"/>
		<option value="The program is unspecified/implementation defined"/>
		<option value="The program is undefined"/>
	</Options>
	<Code>
<![CDATA[
<pre>
#include &#x3C;iostream&#x3E;<br>
class A<br>
{<br>
public:<br>
&#x9;A()<br>
&#x9;{<br>
&#x9;&#x9;std::cout &#x3C;&#x3C; &#x27;a&#x27;;<br>
&#x9;}<br>
&#x9;~A()<br>
&#x9;{<br>
&#x9;&#x9;std::cout &#x3C;&#x3C; &#x27;A&#x27;;<br>
&#x9;}<br>
};<br>
class B: public A <br>
{<br>
public: <br>
&#x9;B()<br>
&#x9;{ <br>
&#x9;&#x9;std::cout &#x3C;&#x3C; &#x27;b&#x27;;<br>
&#x9;}<br>
&#x9;~B()<br>
&#x9;{<br>
&#x9;&#x9;std::cout &#x3C;&#x3C; &#x27;B&#x27;;<br>
&#x9;}<br>
}; <br>
int main()<br>
{<br>
&#x9;B b;<br>
}<br>
</pre>
]]>
	</Code>
	<Level value="Beginner"/>
	</Element>
	<Element reference_id="16">
	<Explanation>
The &#x22;trick&#x22; here is that B::f() is called even though it is private. As &#xA7;11.5.2 in the standard puts it: &#x22;Access is checked at the call point using the type of the expression used to denote the object for which the member function is called&#x22;. The call point here being a.f(), and the type of the expression is A&#x26;.
	</Explanation>
	<Hint>
What is the type of the expression a? What is the dynamic type of a? Which of these is used for access checking, and which is used to select which f() to call?
	</Hint>
	<Question>
According to the C++11 standard, what is output of the following code?
	</Question>
	<Options>
		<option value="The program is guaranteed to output"/>
		<option value="The program has a compilation error"/>
		<option value="The program is unspecified/implementation defined"/>
		<option value="The program is undefined"/>
	</Options>
	<Code>
<![CDATA[
<pre>
#include &#x3C;iostream&#x3E;<br>
class A<br>
{<br>
public: <br>
&#x9;virtual void f()<br>
&#x9;{ <br>
&#x9;&#x9;std::cout &#x3C;&#x3C; &#x22;A&#x22;;<br>
&#x9;}<br>
}; <br>
class B: public A<br>
{<br>
private:<br>
&#x9;void f()<br>
&#x9;{<br>
&#x9;&#x9;std::cout &#x3C;&#x3C; &#x22;B&#x22;;<br>
&#x9;}<br>
}; <br>
void g( A &#x26;a )<br>
{<br>
&#x9;a.f();<br>
}<br>
int main()<br>
{<br>
&#x9;B b;<br>
&#x9;g(b);<br>
}<br>
</pre>
]]>
	</Code>
	<Level value="Beginner"/>
	</Element>
	<Element reference_id="17">
	<Explanation>
Unsigned integers have well defined behaviour when they overflow. When you go one above the largest representable unsigned int, you end up back at zero. According to &#xA7;3.9.1.4 in the C++ standard: &#x22;Unsigned integers, declared unsigned, shall obey the laws of arithmetic modulo 2^n where n is the number of bits in the value representation of that particular size of integer.&#x22;
	</Explanation>
	<Hint>
What happens when an unsigned integer overflows? Is it well-defined?
	</Hint>
	<Question>
According to the C++11 standard, what is output of the following code?
	</Question>
	<Options>
		<option value="The program is guaranteed to output"/>
		<option value="The program has a compilation error"/>
		<option value="The program is unspecified/implementation defined"/>
		<option value="The program is undefined"/>
	</Options>
	<Code>
<![CDATA[
<pre>
#include &#x3C;iostream&#x3E; <br>
#include &#x3C;limits&#x3E; <br>
int main()<br>
{ <br>
&#x9;unsigned int i = std::numeric_limits&#x3C;unsigned int&#x3E;::max(); <br>
&#x9;std::cout &#x3C;&#x3C; ++i;<br>
}<br>
</pre>
]]>
	</Code>
	<Level value="Beginner"/>
	</Element>
	<Element reference_id="18">
	<Explanation>
Signed integer overflow is undefined behaviour according to the standard &#xA7;5.4: &#x22;If during the evaluation of an expression, the result is not mathematically defined or not in the range of representable values for its type, the behavior is undefined.&#x22; Most implementations will just wrap around, so if you try it out on your machine, you will probably see the same as if you had done std::cout &#x3C;&#x3C; std::numeric_limits&#x3C;int&#x3E;::min(); Relying on such undefined behaviour is however _not_ safe. For an interesting example, see http://stackoverflow.com/questions/7682477/why-does-integer-overflow-on-x86-with-gcc-cause-an-infinite-loop
	</Explanation>
	<Hint>
What does the standard have to say about signed integer overflow? Does it differ from unsigned integer overflow? Also, don&#x27;t trust your compiler on this one.
	</Hint>
	<Question>
According to the C++11 standard, what is output of the following code?
	</Question>
	<Options>
		<option value="The program is guaranteed to output"/>
		<option value="The program has a compilation error"/>
		<option value="The program is unspecified/implementation defined"/>
		<option value="The program is undefined"/>
	</Options>
	<Code>
<![CDATA[
<pre>
#include &#x3C;iostream&#x3E; <br>
#include &#x3C;limits&#x3E; <br>
int main()<br>
{<br>
&#x9;int i = std::numeric_limits&#x3C;int&#x3E;::max();<br>
&#x9;std::cout &#x3C;&#x3C; ++i; <br>
}<br>
</pre>
]]>
	</Code>
	<Level value="Intermediate"/>
	</Element>
	<Element reference_id="19">
	<Explanation>
Integer division by zero is undefined behaviour. According to &#xA7;5.6.4 in the standard: &#x22;If the second operand of / or % is zero the behavior is undefined.&#x22;
	</Explanation>
	<Hint>
What happens when you divide an integer by zero?
	</Hint>
	<Question>
According to the C++11 standard, what is output of the following code?
	</Question>
	<Options>
		<option value="The program is guaranteed to output"/>
		<option value="The program has a compilation error"/>
		<option value="The program is unspecified/implementation defined"/>
		<option value="The program is undefined"/>
	</Options>
	<Code>
<![CDATA[
<pre>
#include &#x3C;iostream&#x3E; <br>
int main()<br>
{ <br>
&#x9;int i = 42;<br>
&#x9;int j = 1; <br>
&#x9;std::cout &#x3C;&#x3C; i / --j;<br>
}<br>
</pre>
]]>
	</Code>
	<Level value="Beginner"/>
	</Element>
	<Element reference_id="20">
	<Explanation>
This is a way to get polymorphic behaviour for operator &#x3C;&#x3C;.
	</Explanation>
	<Options>
		<option value="The program is guaranteed to output"/>
		<option value="The program has a compilation error"/>
		<option value="The program is unspecified/implementation defined"/>
		<option value="The program is undefined"/>
	</Options>
	<Question>
According to the C++11 standard, what is output of the following code?
	</Question>
	<Code>
<![CDATA[
<pre>
#include &#x3C;iostream&#x3E; <br>
struct A<br>
{<br>
&#x9;virtual std::ostream &#x26;put( std::ostream &#x26;o ) const<br>
&#x9;{<br>
&#x9;&#x9;return o &#x3C;&#x3C; &#x27;A&#x27;;<br>
&#x9;}<br>
};<br>
struct B: A<br>
{<br>
&#x9;virtual std::ostream &#x26;put( std::ostream &#x26;ov ) const<br>
&#x9;{<br>
&#x9;&#x9;return o &#x3C;&#x3C; &#x27;B&#x27;;<br>
&#x9;}<br>
}; <br>
std::ostream &#x26;operator&#x3C;&#x3C;( std::ostream &#x26;o, const A &#x26;a )<br>
{ <br>
&#x9;return a.put( o );<br>
} <br>
int main()<br>
{<br>
&#x9;B b;<br>
&#x9;std::cout &#x3C;&#x3C; b;<br>
}<br>
</pre>
]]>
	</Code>
	<Level value="Beginner"/>
	<Hint>
What is the dynamic type of a?
	</Hint>
	</Element>
	<Element reference_id="21">
	<Explanation>
When the array is initialized, the default constructor is called once for each of the two objects in it. Then we iterate over the array using auto, which in our case is deduced to be A. This means the copy constructor will be called before f() for each iteration, printing BCBC. (Just as if we had written for (A x: a). If we want to avoid the copy constructor, we can write for (auto&#x26; x : a) instead. Then the loop would print CC. (Just as if we had written for (A&#x26; x: a).
	</Explanation>
	<Options>
		<option value="The program is guaranteed to output"/>
		<option value="The program has a compilation error"/>
		<option value="The program is unspecified/implementation defined"/>
		<option value="The program is undefined"/>
	</Options>
	<Question>
According to the C++11 standard, what is output of the following code?
	</Question>
	<Code>
<![CDATA[
<pre>
#include &#x3C;iostream&#x3E; <br>
struct A<br>
{<br>
&#x9;A()<br>
&#x9;{ <br>
&#x9;&#x9;std::cout &#x3C;&#x3C; &#x22;A&#x22;; <br>
&#x9;}<br>
&#x9;A( const A &#x26;a )<br>
&#x9;{<br>
&#x9;&#x9;std::cout &#x3C;&#x3C; &#x22;B&#x22;;<br>
&#x9;} <br>
&#x9;virtual void f()<br>
&#x9;{<br>
&#x9;&#x9;std::cout &#x3C;&#x3C; &#x22;C&#x22;; <br>
&#x9;}<br>
};<br>
int main() <br>
{<br>
&#x9;A a[2];<br>
&#x9;for( auto x : a )<br>
&#x9;{<br>
&#x9;&#x9;x.f();<br>
&#x9;}<br>
}<br>
</pre>
]]>
	</Code>
	<Level value="Beginner"/>
	<Hint>
When are array elements initialized? What is the difference between auto and auto&#x26;?
	</Hint>
	</Element>
	<Element reference_id="22">
	<Explanation>
Even though foo() is virtual, it is not considered to be so during the execution of constructors and destructors. Rationale: If an object of type B is being constructed, first the constructor of A is called, then the constructor of B. Thus, during A&#x27;s constructor, the &#x22;B part&#x22; of the object has not been constructed yet, and should not be used. One could easily imagine that B::foo() would use the &#x22;B part&#x22; of the object, so it would be dangerous for A&#x27;s constructor to call it. When the object is destroyed, B&#x27;s destructor is called first, then A&#x27;s destructor, leading to the same problem.
	</Explanation>
	<Hint>
Are there times when virtual functions are not considered virtual?
	</Hint>
	<Question>
According to the C++11 standard, what is output of the following code?
	</Question>
	<Options>
		<option value="The program is guaranteed to output"/>
		<option value="The program has a compilation error"/>
		<option value="The program is unspecified/implementation defined"/>
		<option value="The program is undefined"/>
	</Options>
	<Code>
<![CDATA[
<pre>
#include &#x3C;iostream&#x3E;<br>
struct A<br>
{<br>
&#x9;A()<br>
&#x9;{ <br>
&#x9;&#x9;foo();<br>
&#x9;} <br>
&#x9;virtual ~A()<br>
&#x9;{ <br>
&#x9;&#x9;foo(); <br>
&#x9;} <br>
&#x9;virtual void foo() <br>
&#x9;{ <br>
&#x9;&#x9;std::cout &#x3C;&#x3C; &#x22;1&#x22;; <br>
&#x9;} <br>
&#x9;void bar() <br>
&#x9;{ <br>
&#x9;&#x9;foo(); <br>
&#x9;}<br>
}; <br>
struct B: public A <br>
{<br>
&#x9;virtual void foo() <br>
&#x9;{ <br>
&#x9;&#x9;std::cout &#x3C;&#x3C; &#x22;2&#x22;; <br>
&#x9;} <br>
}; <br>
int main()<br>
{<br>
&#x9;B b;<br>
&#x9;b.bar();<br>
}<br>
</pre>
]]>
	</Code>
	<Level value="Intermediate"/>
	</Element>
	<Element reference_id="23">
	<Options>
		<option value="The program is guaranteed to output"/>
		<option value="The program has a compilation error"/>
		<option value="The program is unspecified/implementation defined"/>
		<option value="The program is undefined"/>
	</Options>
	<Explanation>
This program has no output. X x(); is a function prototype, not a variable definition. Remove the parentheses (or since C++11, replace them with {}), and the program will output X.
	</Explanation>
	<Question>
According to the C++11 standard, what is output of the following code?
	</Question>
	<Code>
<![CDATA[
<pre>
#include &#x3C;iostream&#x3E;<br>
struct X <br>
{ <br>
&#x9;X()<br>
&#x9;{ <br>
&#x9;&#x9;std::cout &#x3C;&#x3C; &#x22;X&#x22;; <br>
&#x9;}<br>
}; <br>
int main()<br>
{<br>
&#x9;X x();<br>
}<br>
</pre>
]]>
	</Code>
	<Level value="Beginner"/>
	<Hint>
What is the difference between X x;and X x();?
	</Hint>
	</Element>
	<Element reference_id="24">
	<Explanation>
The compilation error is on the line y.f(), but the source of the problem is Y y(X()); This could be interpreted as a a variable definition (which was the intention of the programmer in this example), or as a definition of a function y, returning an object of type Y, taking a function (with no arguments, returning an object of type X) as its argument. The compiler is required by the standard to choose the second interpretation, which means that y.f() does not compile (since y is now a function, not an object of type Y). Wikipedia has a concise explanation: http://en.wikipedia.org/wiki/Most_vexing_parse, and the standard has more in &#xA7;6.8. To fix the problem, change Y y(X()) to either Y y{X{}} (modern C++) or Y y((X())) (pre-C++11)
	</Explanation>
	<Hint>
Have you heard about the &#x22;most vexing parse&#x22;? Does it apply here?
	</Hint>
	<Question>
According to the C++11 standard, what is output of the following code?
	</Question>
	<Options>
		<option value="The program is guaranteed to output"/>
		<option value="The program has a compilation error"/>
		<option value="The program is unspecified/implementation defined"/>
		<option value="The program is undefined"/>
	</Options>
	<Code>
<![CDATA[
<pre>
#include &#x3C;iostream&#x3E; <br>
struct X <br>
{<br>
&#x9;X()<br>
&#x9;{ <br>
&#x9;&#x9;std::cout &#x3C;&#x3C; &#x22;X&#x22;; <br>
&#x9;} <br>
}; <br>
struct Y<br>
{<br>
&#x9;Y( const X &#x26;x )<br>
&#x9;{ <br>
&#x9;&#x9;std::cout &#x3C;&#x3C; &#x22;Y&#x22;; <br>
&#x9;} <br>
&#x9;void f()<br>
&#x9;{<br>
&#x9;&#x9;std::cout &#x3C;&#x3C; &#x22;f&#x22;; <br>
&#x9;} <br>
}; <br>
int main()<br>
{ <br>
&#x9;Y y( X() ); <br>
&#x9;y.f();<br>
}<br>
</pre>
]]>
	</Code>
	<Level value="Hard"/>
	</Element>
	<Element reference_id="25">
	<Explanation>
The first line in main(), X x; is straightforward, it calls the default constructor. The next two lines is the heart of the question: The difference between X y(x) and X z = y is not that the first calls the copy constructor, and the second calls the copy assignment operator. The difference is that the first is direct initialization (&#xA7;8.5.15 in the standard) and the second is copy initialization (&#xA7;8.5.14). &#xA7;8.5.16 says: &#x22;If the initialization is direct-initialization, or if it is copy-initialization where the (...) source type is the same class as (...) the class of the destination, constructors are considered.&#x22; So both our cases use the copy constructor. Not until z = x; do we have an actual assignment that uses the assignment operator. See http://stackoverflow.com/questions/1051379/is-there-a-difference-in-c-between-copy-initialization-and-direct-initializati/1051468#1051468 for a more detailed discussion of direct vs. copy initialization.
	</Explanation>
	<Hint>
What is the difference between direct initialization and copy initialization? Do they in any way relate to the copy constructor and copy assignment operator?
	</Hint>
	<Question>
According to the C++11 standard, what is output of the following code?
	</Question>
	<Options>
		<option value="The program is guaranteed to output"/>
		<option value="The program has a compilation error"/>
		<option value="The program is unspecified/implementation defined"/>
		<option value="The program is undefined"/>
	</Options>
	<Code>
<![CDATA[
<pre>
#include &#x3C;iostream&#x3E;<br>
struct X<br>
{<br>
&#x9;X()<br>
&#x9;{ <br>
&#x9;&#x9;std::cout &#x3C;&#x3C; &#x22;a&#x22;;<br>
&#x9;} <br>
&#x9;X( const X &#x26;x )<br>
&#x9;{<br>
&#x9;&#x9;std::cout &#x3C;&#x3C; &#x22;b&#x22;;<br>
&#x9;}<br>
&#x9;const X &#x26;operator=( const X &#x26;x )<br>
&#x9;{<br>
&#x9;&#x9;std::cout &#x3C;&#x3C; &#x22;c&#x22;; <br>
&#x9;&#x9;return *this;<br>
&#x9;}<br>
};<br>
int main()<br>
{<br>
&#x9;X x;<br>
&#x9;X y( x );<br>
&#x9;X z = y; <br>
&#x9;z = x;<br>
}<br>
</pre>
]]>
	</Code>
	<Level value="Intermediate"/>
	</Element>
	<Element reference_id="26">
	<Explanation>
We throw a SpecialException. It is derived from GeneralException, but is caught by value, so e will have the dynamic type GeneralException, not SpecialException. This is known as slicing. Instead, we should have caught it by reference catch (GeneralException&#x26; e), then its dynamic type would be SpecialException, and the program would output S.
	</Explanation>
	<Hint>
Pass by value vs. pass by reference
	</Hint>
	<Question>
According to the C++11 standard, what is output of the following code?
	</Question>
	<Options>
		<option value="The program is guaranteed to output"/>
		<option value="The program has a compilation error"/>
		<option value="The program is unspecified/implementation defined"/>
		<option value="The program is undefined"/>
	</Options>
	<Code>
<![CDATA[
<pre>
#include &#x3C;iostream&#x3E;<br>
struct GeneralException<br>
{<br>
&#x9;virtual void print()<br>
&#x9;{ <br>
&#x9;&#x9;std::cout &#x3C;&#x3C; &#x22;G&#x22;;<br>
&#x9;}<br>
}; <br>
struct SpecialException : public GeneralException<br>
{<br>
&#x9;void print() override<br>
&#x9;{<br>
&#x9;&#x9;std::cout &#x3C;&#x3C; &#x22;S&#x22;;<br>
&#x9;}<br>
};<br>
void f()<br>
{<br>
&#x9;throw SpecialException();<br>
}<br>
int main()<br>
{<br>
&#x9;try <br>
&#x9;{<br>
&#x9;&#x9;f(); <br>
&#x9;} <br>
&#x9;catch ( GeneralException e )<br>
&#x9;{<br>
&#x9;&#x9;e.print();<br>
&#x9;}<br>
}<br>
</pre>
]]>
	</Code>
	<Level value="Beginner"/>
	</Element>
	<Element reference_id="27">
	<Explanation>
To answer this we need to look at overload resolution of vector&#x27;s constructors: &#xA7;23.3.6.2&#xB6;3 says (somewhat redacted): vector(size_type n, const T&#x26; value); Effects: Constructs a vector with n copies of value So v1 contains one &#x22;2&#x22;. &#xA7;13.3.1.7 says (in summary) that when non-aggregate classes (such as vector) are list-initialized&#x2020; and have an initializer list constructor (again, like vector), that constructor is chosen, and the argument list consists of the initializer list as a single argument. (&#x2020;: 8.5.4&#xB6;1: List-initialization is initialization of an object or reference from a braced-init-list.) So v2 is initialized from the elements (aka initializer-clauses) in the braced-init-list, and contains the elements &#x22;1&#x22; and &#x22;2&#x22;.
	</Explanation>
	<Hint>
Which constructors are invoked for v1 and v2? How is a vector constructed from an initializer list?
	</Hint>
	<Question>
According to the C++11 standard, what is output of the following code?
	</Question>
	<Options>
		<option value="The program is guaranteed to output"/>
		<option value="The program has a compilation error"/>
		<option value="The program is unspecified/implementation defined"/>
		<option value="The program is undefined"/>
	</Options>
	<Code>
<![CDATA[
<pre>
#include &#x3C;iostream&#x3E;<br>
#include &#x3C;vector&#x3E;<br>
int main()<br>
{<br>
&#x9;std::vector&#x3C;int&#x3E; v1( 1, 2 );<br>
&#x9;std::vector&#x3C;int&#x3E; v2{ 1, 2 };<br>
&#x9;<br>
&#x9;std::cout &#x3C;&#x3C; v1.size() &#x3C;&#x3C; v2.size();<br>
}<br>
</pre>
]]>
	</Code>
	<Level value="Beginner"/>
	</Element>
	<Element reference_id="28">
	<Explanation>
According to &#xA7; 7.1.6.2.4 in the C++ standard: &#x22;The type denoted by decltype(e) is de?ned as follows: &#x2014; if e is an unparenthesized id-expression [...], decltype(e) is the type of the entity named by e.&#x22; The type of a is int, so the type of b is also int.
	</Explanation>
	<Options>
		<option value="The program is guaranteed to output"/>
		<option value="The program has a compilation error"/>
		<option value="The program is unspecified/implementation defined"/>
		<option value="The program is undefined"/>
	</Options>
	<Question>
According to the C++11 standard, what is output of the following code?
	</Question>
	<Code>
<![CDATA[
<pre>
#include &#x3C;iostream&#x3E; <br>
int main() <br>
{<br>
&#x9;int a = 0; <br>
&#x9;decltype( a ) b = a;<br>
&#x9;b++; <br>
&#x9;std::cout &#x3C;&#x3C; a &#x3C;&#x3C; b;<br>
}<br>
</pre>
]]>
	</Code>
	<Level value="Beginner"/>
	<Hint>
What type is decltype(a)?
	</Hint>
	</Element>
	<Element reference_id="29">
	<Explanation>
According to &#xA7; 7.1.6.2.4 in the C++ standard: &#x22;The type denoted by decltype(e) is de?ned as follows: &#x2014; if e is an unparenthesized id-expression or an unparenthesized class member access (5.2.5), decltype(e) is the type of the entity named by e. If there is no such entity, or if e names a set of overloaded functions, the program is ill-formed; &#x2014; otherwise, if e is an xvalue, decltype(e) is T&#x26;&#x26;, where T is the type of e; &#x2014; otherwise, if e is an lvalue, decltype(e) is T&#x26;, where T is the type of e; &#x2014; otherwise, decltype(e) is the type of e.&#x22; Because a is encapsulated in parentheses, it doesn&#x27;t qualify for the first case, it is treated as an lvalue, therefore b&#x27;s type is int&#x26;, not int.
	</Explanation>
	<Options>
		<option value="The program is guaranteed to output"/>
		<option value="The program has a compilation error"/>
		<option value="The program is unspecified/implementation defined"/>
		<option value="The program is undefined"/>
	</Options>
	<Question>
According to the C++11 standard, what is output of the following code?
	</Question>
	<Code>
<![CDATA[
<pre>
#include &#x3C;iostream&#x3E; <br>
int main()<br>
{<br>
&#x9;int a = 0;<br>
&#x9;decltype(( a )) b = a; <br>
&#x9;b++; <br>
&#x9;std::cout &#x3C;&#x3C; a &#x3C;&#x3C; b;<br>
}<br>
</pre>
]]>
	</Code>
	<Level value="Intermediate"/>
	<Hint>
decltype(( a ))is not the same as decltype( a ).
	</Hint>
	</Element>
	<Element reference_id="30">
	<Explanation>
&#xA7;5.2.1 in the standard says &#x22;The expression E1[E2] is identical (by definition) to *((E1)+(E2))&#x22;. In our case 1[&#x22;ABC&#x22;] is identical to *(1+&#x22;ABC&#x22;). Since the plus operator is commutative, this is identical to *(&#x22;ABC&#x22;+1), which is identical to the more familiar &#x22;ABC&#x22;[1].
	</Explanation>
	<Options>
		<option value="The program is guaranteed to output"/>
		<option value="The program has a compilation error"/>
		<option value="The program is unspecified/implementation defined"/>
		<option value="The program is undefined"/>
	</Options>
	<Question>
According to the C++11 standard, what is output of the following code?
	</Question>
	<Code>
<![CDATA[
<pre>
#include &#x3C;iostream&#x3E; <br>
int main()<br>
{<br>
&#x9;std::cout &#x3C;&#x3C; 1[&#x22;ABC&#x22;];<br>
}<br>
</pre>
]]>
	</Code>
	<Level value="Intermediate"/>
	<Hint>
&#xA7;5.2.1 in the standard says &#x22;The expression E1[E2] is identical (by definition) to *((E1)+(E2))&#x22;.
	</Hint>
	</Element>
	<Element reference_id="31">
	<Explanation>
According to &#xA7;8.5.4.3 in the C++ standard: &#x22;List-initialization of an object or reference of type T is de?ned as follows: &#x2014; If the initializer list has no elements and T is a class type with a default constructor, the object is value-initialized. &#x2014; Otherwise, if T is an aggregate, aggregate initialization is performed (&#xA7;8.5.1). &#x2014; Otherwise, if T is a specialization of std::initializer_list&#x3C;E&#x3E;, an initializer_list object is constructed as described below and used to initialize the object according to the rules for initialization of an object from a class of the same type (&#xA7;8.5). &#x2014; Otherwise, if T is a class type, constructors are considered. The applicable constructors are enumerated and the best one is chosen through overload resolution (&#xA7;13.3, &#xA7;13.3.1.7). If a narrowing conversion (see below) is required to convert any of the arguments, the program is ill-formed. &#x2014; (more cases...)&#x22; a1 is default initialized, as described in &#xA7;8.5.0.11 a2 doesn&#x27;t actually use the initializer_list constructor with a list of zero elements, but the default constructor, as described by the first option of the list above. a3&#x27;s and a4&#x27;s constructor is chosen in overload resolution, as described in &#xA7;13.3.1.7: &#x22;When objects of non-aggregate class type T are list-initialized (&#xA7;8.5.4), overload resolution selects the constructor in two phases: &#x2014; Initially, the candidate functions are the initializer-list constructors (&#xA7;8.5.4) of the class T and the argument list consists of the initializer list as a single argument. &#x2014; If no viable initializer-list constructor is found, overload resolution is performed again, where the candidate functions are all the constructors of the class T and the argument list consists of the elements of the initializer list.&#x22; Initializer list constructors are greedy, so even though A(int) constructor is available, the standard mandates that initializer_list&#x3C;int&#x3E; is prioritized, and if - and only if - it&#x27;s not available, the compiler is allowed to look for other constructors. (This is why it is not recommended to provide a constructor that ambiguously overloads with an initializer_list constructor. See the answer to #4 in http://herbsutter.com/2013/05/09/gotw-1-solution/ )
	</Explanation>
	<Hint>
How greedy are initializer-list constructors?
	</Hint>
	<Question>
According to the C++11 standard, what is output of the following code?
	</Question>
	<Options>
		<option value="The program is guaranteed to output"/>
		<option value="The program has a compilation error"/>
		<option value="The program is unspecified/implementation defined"/>
		<option value="The program is undefined"/>
	</Options>
	<Code>
<![CDATA[
<pre>
#include &#x3C;initializer_list&#x3E;<br>
#include &#x3C;iostream&#x3E;<br>
struct A<br>
{<br>
&#x9;A()<br>
&#x9;{<br>
&#x9;&#x9;std::cout &#x3C;&#x3C; &#x22;1&#x22;;<br>
&#x9;}<br>
&#x9;A( int )<br>
&#x9;{<br>
&#x9;&#x9;std::cout &#x3C;&#x3C; &#x22;2&#x22;;<br>
&#x9;}<br>
&#x9;A( std::initializer_list&#x3C;int&#x3E; )<br>
&#x9;{<br>
&#x9;&#x9;std::cout &#x3C;&#x3C; &#x22;3&#x22;;<br>
&#x9;}<br>
}; <br>
int main( int argc, char *argv[] )<br>
{<br>
&#x9;A a1;<br>
&#x9;A a2{};<br>
&#x9;A a3{ 1 };<br>
&#x9;A a4{ 1, 2 };<br>
}<br>
</pre>
]]>
	</Code>
	<Level value="Intermediate"/>
	</Element>
	<Element reference_id="32">
	<Options>
		<option value="The program is guaranteed to output"/>
		<option value="The program has a compilation error"/>
		<option value="The program is unspecified/implementation defined"/>
		<option value="The program is undefined"/>
	</Options>
	<Explanation>
arr is an array of X, not of pointers to X. When an object of type Y is stored in it, it is converted to X, and we lose the &#x22;Y part&#x22; of the object. This is commonly known as &#x22;slicing&#x22;.
	</Explanation>
	<Question>
According to the C++11 standard, what is output of the following code?
	</Question>
	<Code>
<![CDATA[
<pre>
#include &#x3C;iostream&#x3E;<br>
struct X<br>
{<br>
&#x9;virtual void f() const<br>
&#x9;{<br>
&#x9;&#x9;std::cout &#x3C;&#x3C; &#x22;X&#x22;;<br>
&#x9;}<br>
}; <br>
struct Y: public X <br>
{<br>
&#x9;void f() const<br>
&#x9;{<br>
&#x9;&#x9;std::cout &#x3C;&#x3C; &#x22;Y&#x22;;<br>
&#x9;}<br>
};<br>
void print( const X &#x26;x )<br>
{ <br>
&#x9;x.f();<br>
} <br>
int main()<br>
{ <br>
&#x9;X arr[1];<br>
&#x9;Y y1;<br>
&#x9;arr[0] = y1; <br>
&#x9;<br>
&#x9;print( y1 ); <br>
&#x9;print( arr[0] );<br>
}<br>
</pre>
]]>
	</Code>
	<Level value="Beginner"/>
	<Hint>
Do arrays have polymorphic behaviour?
	</Hint>
	</Element>
	<Element reference_id="33">
	<Options>
		<option value="The program is guaranteed to output"/>
		<option value="The program has a compilation error"/>
		<option value="The program is unspecified/implementation defined"/>
		<option value="The program is undefined"/>
	</Options>
	<Explanation>
The destructor of a future returned from async is required to block until the async task has finished (see elaboration below). Since we don&#x27;t assign the futures that are returned from async() to anything, they are destroyed at the end of the full expression (at the end of the line in this case). &#xA7;12.2&#xB6;3 in the standard: &#x22;Temporary objects are destroyed as the last step in evaluating the full-expression (1.9) that (lexically) contains the point where they were created.&#x22; This means that the first async call is guaranteed to finish execution before async() is called the second time, so, while the assignments themselves may happen in different threads, they are synchronized. Elaboration on synchronization: According to &#xA7; 30.6.8&#xB6;5 of the standard: Synchronization: [...] If the implementation chooses the launch::async policy, &#x2014; the associated thread completion synchronizes with (1.10) the return from the first function that successfully detects the ready status of the shared state or with the return from the last function that releases the shared state, whichever happens first. In this case, the destructor of std::future&#x3C;&#x3E; returned by the async() call is &#x22;the last function that releases the shared state&#x22;, therefore it synchronizes with (waits for) the thread completion. Scott Meyers writes more about this http://scottmeyers.blogspot.com/2013/03/stdfutures-from-stdasync-arent-special.html
	</Explanation>
	<Question>
According to the C++11 standard, what is output of the following code?
	</Question>
	<Code>
<![CDATA[
<pre>
#include &#x3C;iostream&#x3E;<br>
#include &#x3C;string&#x3E; <br>
#include &#x3C;future&#x3E; <br>
int main()<br>
{<br>
&#x9;std::string x = &#x22;x&#x22;; <br>
&#x9;std::async( std::launch::async, [&#x26;x]() { x = &#x22;y&#x22;; } ); <br>
&#x9;std::async( std::launch::async, [&#x26;x]() { x = &#x22;z&#x22;; } ); <br>
&#x9;<br>
&#x9;std::cout &#x3C;&#x3C; x;<br>
}<br>
</pre>
]]>
	</Code>
	<Level value="Intermediate"/>
	<Hint>
When we don&#x27;t call get() on a future returned from async(), when is the asynchronous task guaranteed to complete?
	</Hint>
	</Element>
	<Element reference_id="34">
	<Options>
		<option value="The program is guaranteed to output"/>
		<option value="The program has a compilation error"/>
		<option value="The program is unspecified/implementation defined"/>
		<option value="The program is undefined"/>
	</Options>
	<Explanation>
&#xA7;12.2&#xB6;3 in the standard: &#x22;Temporary objects are destroyed as the last step in evaluating the full-expression (...) that (lexically) contains the point where they were created.&#x22; This means that normally the temporaries returned from C(1) and C(2) should be destroyed at the end of the line. However: &#xA7;12.2&#xB6;5 states: &#x22;(...)when a reference is bound to a temporary. The temporary to which the reference is bound (...) persists for the lifetime of the reference&#x22;, so the lifetime of the temporary returned by C(1) is extended to the end of main(). The temporary returned by C(2) is still destroyed at the end of the line, so it gets destroyed before the one returned by C(1).
	</Explanation>
	<Question>
According to the C++11 standard, what is output of the following code?
	</Question>
	<Code>
<![CDATA[
<pre>
#include &#x3C;iostream&#x3E; <br>
class C<br>
{<br>
public: <br>
&#x9;C( int i ): i( i )<br>
&#x9;{<br>
&#x9;&#x9;std::cout &#x3C;&#x3C; i;<br>
&#x9;} <br>
&#x9;~C() <br>
&#x9;{<br>
&#x9;&#x9;std::cout &#x3C;&#x3C; i + 5; <br>
&#x9;}<br>
private:<br>
&#x9;int i; <br>
};<br>
int main()<br>
{<br>
&#x9;const C &#x26;c = C( 1 );<br>
&#x9;C( 2 );<br>
}<br>
</pre>
]]>
	</Code>
	<Level value="Intermediate"/>
	<Hint>
When are temporaries destroyed? What happens if you bind a const reference to it?
	</Hint>
	</Element>
	<Element reference_id="35">
	<Explanation>
There is a compilation error when attempting to declare A::createB() a friend of B. To declare A::createB() a friend of B, the compiler needs to know that that function exists. Since it has only seen the declaration of A so far, not the full definition, it cannot know this.
	</Explanation>
	<Options>
		<option value="The program is guaranteed to output"/>
		<option value="The program has a compilation error"/>
		<option value="The program is unspecified/implementation defined"/>
		<option value="The program is undefined"/>
	</Options>
	<Question>
According to the C++11 standard, what is output of the following code?
	</Question>
	<Code>
<![CDATA[
<pre>
#include &#x3C;iostream&#x3E; <br>
class A; <br>
class B<br>
{<br>
&#x9;B()<br>
&#x9;{<br>
&#x9;&#x9;std::cout &#x3C;&#x3C; &#x22;B&#x22;;<br>
&#x9;}<br>
public:<br>
&#x9;friend B A::createB(); <br>
}; <br>
class A<br>
{<br>
public: <br>
&#x9;A()<br>
&#x9;{<br>
&#x9;&#x9;std::cout &#x3C;&#x3C; &#x22;A&#x22;;<br>
&#x9;}<br>
&#x9;B createB()<br>
&#x9;{<br>
&#x9;&#x9;return B();<br>
&#x9;}<br>
}; <br>
int main()<br>
{<br>
&#x9;A a;<br>
&#x9;B b = a.createB();<br>
}<br>
</pre>
]]>
	</Code>
	<Level value="Beginner"/>
	<Hint>
What does B have to know about A in order to declare A::createB() a friend?
	</Hint>
	</Element>
	<Element reference_id="36">
	<Explanation>
The Standard says this about jump statements: &#xA7;6.6&#xB6;2 Transfer [...] back past an initialized variable with automatic storage duration involves the destruction of variables with automatic storage duration that are in scope at the point transferred from but not at the point transferred to.
	</Explanation>
	<Options>
		<option value="The program is guaranteed to output"/>
		<option value="The program has a compilation error"/>
		<option value="The program is unspecified/implementation defined"/>
		<option value="The program is undefined"/>
	</Options>
	<Question>
According to the C++11 standard, what is output of the following code?
	</Question>
	<Code>
<![CDATA[
<pre>
#include &#x3C;iostream&#x3E;<br>
using namespace std;<br>
class A<br>
{<br>
public: <br>
&#x9;A()<br>
&#x9;{<br>
&#x9;&#x9;cout &#x3C;&#x3C; &#x22;a&#x22;;<br>
&#x9;}<br>
&#x9;~A()<br>
&#x9;{<br>
&#x9;&#x9;cout &#x3C;&#x3C; &#x22;A&#x22;;<br>
&#x9;}<br>
};<br>
int i = 1; <br>
int main()<br>
{<br>
label:<br>
&#x9;A a;<br>
&#x9;if ( i-- ) goto label;<br>
}<br>
</pre>
]]>
	</Code>
	<Level value="Intermediate"/>
	<Hint>
Control passes through A a; twice. Does it make more sense to construct a both times, or just the first? Should the destructor be called the same number of times as the constructor?
	</Hint>
	</Element>
	<Element reference_id="37">
	<Explanation>
According to &#xA7;7.5&#xB6;7 in the standard : A declaration directly contained in a linkage-specification is treated as if it contains the extern specifier (&#xA7;7.1.1) for the purpose of determining the linkage of the declared name and whether it is a definition.     extern &#x22;C&#x22; int x; //is just a declaration     extern &#x22;C&#x22; { int y; } //is a definition And according to &#xA7;3.2&#xB6;3: &#x22;Every program shall contain exactly one definition of every non-inline function or variable that is odr-used in that program; no diagnostic required.&#x22; The result: x is never defined but it is optional for the compiler to print an error. The behaviour of this program is undefined.
	</Explanation>
	<Options>
		<option value="The program is guaranteed to output"/>
		<option value="The program has a compilation error"/>
		<option value="The program is unspecified/implementation defined"/>
		<option value="The program is undefined"/>
	</Options>
	<Question>
According to the C++11 standard, what is output of the following code?
	</Question>
	<Code>
<![CDATA[
<pre>
#include &#x3C;iostream&#x3E; <br>
extern &#x22;C&#x22; int x; <br>
extern &#x22;C&#x22;<br>
{ <br>
&#x9;int y;<br>
} <br>
int main()<br>
{<br>
&#x9;std::cout &#x3C;&#x3C; x &#x3C;&#x3C; y; <br>
&#x9;return 0;<br>
}<br>
</pre>
]]>
	</Code>
	<Level value="Hard"/>
	<Hint>
Is there a difference between the two extern syntaxes? Something to do with declarations and definitions?
	</Hint>
	</Element>
	<Element reference_id="38">
	<Explanation>
The goal of this question is to demonstrate that the evaluation order of elements in an initializer list is specified (as opposed to the arguments to a function call). &#xA7;8.5.4&#xB6;4: Within the initializer-list of a braced-init-list, the initializer-clauses, including any that result from pack expansions (&#xA7;14.5.3), are evaluated in the order in which they appear. If h took two ints instead of a vector&#x3C;int&#x3E;, and was called like this: h(f(), g()); the program would be unspecified, and could either print fg or gf.
	</Explanation>
	<Options>
		<option value="The program is guaranteed to output"/>
		<option value="The program has a compilation error"/>
		<option value="The program is unspecified/implementation defined"/>
		<option value="The program is undefined"/>
	</Options>
	<Question>
According to the C++11 standard, what is output of the following code?
	</Question>
	<Code>
<![CDATA[
<pre>
#include &#x3C;iostream&#x3E;<br>
#include &#x3C;vector&#x3E; <br>
int f()<br>
{<br>
&#x9;std::cout &#x3C;&#x3C; &#x22;f&#x22;;<br>
&#x9;return 0;<br>
}<br>
int g()<br>
{<br>
&#x9;std::cout &#x3C;&#x3C; &#x22;g&#x22;;<br>
&#x9;return 0;<br>
}<br>
void h( std::vector&#x3C;int&#x3E; v )<br>
{<br>
}<br>
int main()<br>
{<br>
&#x9;h( { f(), g() } );<br>
}<br>
</pre>
]]>
	</Code>
	<Level value="Intermediate"/>
	<Hint>
What does the standard say about the evaluation order of elements in an initializer list?
	</Hint>
	</Element>
	<Element reference_id="39">
	<Explanation>
The compiler tries to deduce T for every parameter and checks if the deduced types match. Because a lambda is of completely different type, it cannot be matched against std::function&#x3C;void(T)&#x3E; and the deduction process fails. This problem can be fixed by turning the first parameter into a so-called nondeduced context. &#xA7;14.8.2.5&#xB6;5 in the standard: &#x22;The nondeduced contexts are: - The nested-name-specifier of a type that was specified using a qualified-id. - (...) When a type name is specified in a way that includes a nondeduced context, all of the types that comprise that type name are also nondeduced. However, a compound type can include both deduced and nondeduced types. [Example: If a type is specified as A&#x3C;T&#x3E;::B&#x3C;T2&#x3E;, both T and T2 are nondeduced. Likewise, if a type is specified as A&#x3C;I+J&#x3E;::X&#x3C;T&#x3E;, I, J, and T are nondeduced. If a type is specified as void f(typename A&#x3C;T&#x3E;::B, A&#x3C;T&#x3E;), the T in A&#x3C;T&#x3E;::B is nondeduced but the T in A&#x3C;T&#x3E; is deduced. ]&#x22; In particular, a helper struct template that typedefs the template parameter can be used:     template &#x3C;typename T&#x3E;     struct identity     {         typedef T type;     }; This helper struct can then turn std::function&#x3C;void(T)&#x3E; into a nondeduced context as shown in the standard:     template &#x3C;typename T&#x3E;     void call_with(typename identity&#x3C;std::function&#x3C;void(T)&#x3E;&#x3E;::type f, T val)     {         f(val);     } Note that identity is in namespace std in some stdlib implementations, but it not actually part of the C++11 standard. The problem can also be solved in a less general way (at each call site) by explicitly specifying the template argument:     call_with&#x3C;int&#x3E;(print, 42);
	</Explanation>
	<Hint>
What is the type of print, and how will it match the template parameter?
	</Hint>
	<Question>
According to the C++11 standard, what is output of the following code?
	</Question>
	<Options>
		<option value="The program is guaranteed to output"/>
		<option value="The program has a compilation error"/>
		<option value="The program is unspecified/implementation defined"/>
		<option value="The program is undefined"/>
	</Options>
	<Code>
<![CDATA[
<pre>
#include &#x3C;functional&#x3E;<br>
#include &#x3C;iostream&#x3E; <br>
template &#x3C;typename T&#x3E; <br>
void call_with( std::function&#x3C;void(T)&#x3E; f, T val )<br>
{<br>
&#x9;f( val );<br>
}<br>
int main()<br>
{<br>
&#x9;auto print = [] ( int x )<br>
&#x9;{<br>
&#x9;&#x9;std::cout &#x3C;&#x3C; x; <br>
&#x9;}; <br>
&#x9;call_with( print, 42 );<br>
}<br>
</pre>
]]>
	</Code>
	<Level value="Hard"/>
	</Element>
	<Element reference_id="40">
	<Explanation>
&#xA7;6.6.2 in the standard: &#x22;The continue statement (...) causes control to pass to the loop-continuation portion of the smallest enclosing iteration-statement, that is, to the end of the loop.&#x22; (Not to the beginning.)
	</Explanation>
	<Options>
		<option value="The program is guaranteed to output"/>
		<option value="The program has a compilation error"/>
		<option value="The program is unspecified/implementation defined"/>
		<option value="The program is undefined"/>
	</Options>
	<Question>
According to the C++11 standard, what is output of the following code?
	</Question>
	<Code>
<![CDATA[
<pre>
#include &#x3C;iostream&#x3E; <br>
int main()<br>
{<br>
&#x9;int i = 1;<br>
&#x9;do<br>
&#x9;{<br>
&#x9;&#x9;std::cout &#x3C;&#x3C; i;<br>
&#x9;&#x9;i++; <br>
&#x9;&#x9;if( i &#x3C; 3 ) continue; <br>
&#x9;} while( false ); <br>
&#x9;<br>
&#x9;return 0;<br>
}<br>
</pre>
]]>
	</Code>
	<Level value="Beginner"/>
	<Hint>
Where does continue jump to?
	</Hint>
	</Element>
	<Element reference_id="41">
	<Explanation>
First, b1 is default initialized. All members are initialized before the body of the constructor, so b1.a is default initialized first, and we get the output 14. &#xA7;12.6.2&#xB6;8 in the standard: &#x22;In a non-delegating constructor, if a given non-static data member or base class is not designated by a mem-initializer-id (...) then if the entity is a non-static data member that has a brace-or-equal-initializer, the entity is initialized as specified in &#xA7;8.5 (...) otherwise, the entity is default-initialized.&#x22; Then, b2 is initialized with the move construcor (since std::move(b1)converts the reference to b1 to an xvalue, allowing it to be moved from.) In B&#x27;s move constructor, a is initialized in the initializer list. Even though a is an rvalue reference (and bound to an rvalue), a itself is an lvalue, and cannot be moved from. b2.a is then copy initialized, printing 2, and finally the body of B&#x27;s move constructor prints 6. (If the concept of rvalue references being lvalues is confusing, read http://isocpp.org/blog/2012/11/universal-references-in-c11-scott-meyers . Search for &#x22;In widget&#x22;.)
	</Explanation>
	<Options>
		<option value="The program is guaranteed to output"/>
		<option value="The program has a compilation error"/>
		<option value="The program is unspecified/implementation defined"/>
		<option value="The program is undefined"/>
	</Options>
	<Question>
According to the C++11 standard, what is output of the following code?
	</Question>
	<Code>
<![CDATA[
<pre>
#include &#x3C;iostream&#x3E; <br>
#include &#x3C;utility&#x3E; <br>
struct A<br>
{<br>
&#x9;A()<br>
&#x9;{<br>
&#x9;&#x9;std::cout &#x3C;&#x3C; &#x22;1&#x22;;<br>
&#x9;}<br>
&#x9;A( const A&#x26; )<br>
&#x9;{<br>
&#x9;&#x9;std::cout &#x3C;&#x3C; &#x22;2&#x22;;<br>
&#x9;} <br>
&#x9;A( A&#x26;&#x26; )<br>
&#x9;{<br>
&#x9;&#x9;std::cout &#x3C;&#x3C; &#x22;3&#x22;;<br>
&#x9;}<br>
};<br>
struct B<br>
{<br>
&#x9;A a;<br>
&#x9;B()<br>
&#x9;{<br>
&#x9;&#x9;std::cout &#x3C;&#x3C; &#x22;4&#x22;; <br>
&#x9;}<br>
&#x9;B( const B&#x26; b ): a( b.a )<br>
&#x9;{<br>
&#x9;&#x9;std::cout &#x3C;&#x3C; &#x22;5&#x22;; <br>
&#x9;}<br>
&#x9;B( B&#x26;&#x26; b ): a( b.a )<br>
&#x9;{<br>
&#x9;&#x9;std::cout &#x3C;&#x3C; &#x22;6&#x22;;<br>
&#x9;}<br>
};<br>
int main()<br>
{<br>
&#x9;B b1;<br>
&#x9;B b2 = std::move( b1 );<br>
}<br>
</pre>
]]>
	</Code>
	<Level value="Intermediate"/>
	<Hint>
When members are not mentioned in the member initializer list, when is it initialized? Remember that an rvalue reference is an lvalue (if that doesn&#x27;t make sense, read http://isocpp.org/blog/2012/11/universal-references-in-c11-scott-meyers . Search for &#x22;In widget&#x22;.)
	</Hint>
	</Element>
	<Element reference_id="42">
	<Options>
		<option value="The program is guaranteed to output"/>
		<option value="The program has a compilation error"/>
		<option value="The program is unspecified/implementation defined"/>
		<option value="The program is undefined"/>
	</Options>
	<Explanation>
According to &#xA7;8.3.1.1 in the C++ Standard, &#x22;The cv-qualifiers [e.g., const] apply to the pointer and not to the object pointed to.&#x22; That is, const-ness is shallow with regards to raw pointers and references (and standard types that seek to emulate them, like std::unique_ptr) but not with regard to standard containers such as std::vector. In the code above, the object s is non-const, and so its members all retain their default const-ness and all calls through them invoke the non-const version of C::foo(). However, r refers to its object as a const instance of S. That const-ness changes the behavior of its member v, an std::vector which is &#x22;const-correct&#x22; in the sense that its operator[] returns const C&#x26; (see &#xA7;23.2.3.16) and therefore invokes the const version of C::foo(). The const-ness of r&#x27;s referent is also propagated to its members u and p (meaning one could not perform a mutating operation on u, e.g., calling r.u.reset()), but this has no effect on the instance of C that they both point *to*. That is, the pointers themselves become const, but the pointed-to objects remain non-const. Hence, they both still call the non-const version of C::foo(). The const-ness of the member S::p is the same for both s and r. Because it is declared as a const pointer, it does not change const-ness to follow the const-ness of its instance of S but remains a const pointer to a non-const object.
	</Explanation>
	<Question>
According to the C++11 standard, what is output of the following code?
	</Question>
	<Code>
<![CDATA[
<pre>
#include &#x3C;iostream&#x3E; <br>
#include &#x3C;memory&#x3E;<br>
#include &#x3C;vector&#x3E; <br>
class C<br>
{<br>
public:<br>
&#x9;void foo()<br>
&#x9;{<br>
&#x9;&#x9;std::cout &#x3C;&#x3C; &#x22;A&#x22;;<br>
&#x9;}<br>
&#x9;void foo() const<br>
&#x9;{<br>
&#x9;&#x9;std::cout &#x3C;&#x3C; &#x22;B&#x22;; <br>
&#x9;}<br>
};<br>
struct S<br>
{<br>
&#x9;std::vector&#x3C;C&#x3E; v; <br>
&#x9;std::unique_ptr&#x3C;C&#x3E; u; <br>
&#x9;C *const p;<br>
&#x9;S(): v( 1 ) , u( new C() ), p( u.get() )<br>
&#x9;{<br>
&#x9;}<br>
}; <br>
int main()<br>
{<br>
&#x9;S s; <br>
&#x9;const S &#x26;r = s; <br>
&#x9;s.v[0].foo();<br>
&#x9;s.u-&#x3E;foo(); <br>
&#x9;s.p-&#x3E;foo();<br>
&#x9;r.v[0].foo(); <br>
&#x9;r.u-&#x3E;foo();<br>
&#x9;r.p-&#x3E;foo(); <br>
}<br>
</pre>
]]>
	</Code>
	<Level value="Beginner"/>
	<Hint>
How does const-ness of an object affect members? Is an object pointed to by a const pointer, itself const? What is the const-ness of an object returned by a const vector::operator[]?
	</Hint>
	</Element>
	<Element reference_id="43">
	<Explanation>
According to &#xA7;2.14.4&#xB6;1 in the standard: &#x22;The type of a floating literal is double unless explicitly specified by a suffix.&#x22; The best overload is therefore void f(double).
	</Explanation>
	<Options>
		<option value="The program is guaranteed to output"/>
		<option value="The program has a compilation error"/>
		<option value="The program is unspecified/implementation defined"/>
		<option value="The program is undefined"/>
	</Options>
	<Question>
According to the C++11 standard, what is output of the following code?
	</Question>
	<Code>
<![CDATA[
<pre>
#include &#x3C;iostream&#x3E; <br>
void f( int )<br>
{ <br>
&#x9;std::cout &#x3C;&#x3C; &#x22;i&#x22;; <br>
}<br>
void f( double )<br>
{<br>
&#x9;std::cout &#x3C;&#x3C; &#x22;d&#x22;;<br>
}<br>
void f( float )<br>
{<br>
&#x9;std::cout &#x3C;&#x3C; &#x22;f&#x22;;<br>
} <br>
int main()<br>
{<br>
&#x9;f( 1.0 );<br>
&#x9;return 0;<br>
}<br>
</pre>
]]>
	</Code>
	<Level value="Beginner"/>
	<Hint>
What&#x27;s the type of a floating point literal?
	</Hint>
	</Element>
	<Element reference_id="44">
	<Explanation>
The T&#x26;&#x26; in the the templated functions do not necessarily denote an rvalue reference, it depends on the type that is used to instantiate the template. If instantiated with an lvalue, it collapses to an lvalue reference, if instantiated with an rvalue, it collapses to an rvalue reference. See note [1]. Scott Meyers has written a very good article about this, where he introduces the concept of &#x22;universal references&#x22; (note that this is not C++ standard wording) http://isocpp.org/blog/2012/11/universal-references-in-c11-scott-meyers In this example, all three functions are called once with an lvalue and once with an rvalue. In all cases, calling with an lvalue (i) collapses T&#x26;&#x26; x to T&#x26; x (an lvalue reference), and calling with an rvalue (20) collapses T&#x26;&#x26; x to T&#x26;&#x26; x (an rvalue reference). Inside the functions, x itself is always an lvalue, no matter if its type is an rvalue reference or an lvalue reference. -For the first example, y(int&#x26;) is called for both cases. Output: 11. -For the second example, move(x) obtains an rvalue reference, and y(int&#x26;&#x26;)is called for both cases. Output: 22. -For the third example, forward&#x3C;T&#x3E;(x) obtains an lvalue reference when x is an lvalue reference, and an rvalue reference when x is an rvalue reference, resulting in first a call to y(int&#x26;)and then a call to y(int&#x26;&#x26;). Output: 12. Note [1]: &#xA7;8.3.2&#xB6;6 in the standard: &#x22;If a (...) type template-parameter (&#xA7;14.3.1) (...) denotes a type TR that is a reference to a type T, an attempt to create the type &#x201C;lvalue reference to cv TR&#x201D; creates the type &#x201C;lvalue reference to T&#x201D;, while an attempt to create the type &#x201C;rvalue reference to cv TR&#x201D; creates the type TR.&#x22; The example at the end of that paragraph is is worth a look. Note from the contributor: This demonstrates Scott Meyers&#x27;s advice that use std::forward for universal references, and std::move for rvalue references.
	</Explanation>
	<Options>
		<option value="The program is guaranteed to output"/>
		<option value="The program has a compilation error"/>
		<option value="The program is unspecified/implementation defined"/>
		<option value="The program is undefined"/>
	</Options>
	<Question>
According to the C++11 standard, what is output of the following code?
	</Question>
	<Code>
<![CDATA[
<pre>
#include &#x3C;iostream&#x3E; <br>
#include &#x3C;utility&#x3E; <br>
int y( int &#x26; )<br>
{<br>
&#x9;return 1;<br>
} <br>
int y( int &#x26;&#x26; )<br>
{<br>
&#x9;return 2;<br>
}<br>
template &#x3C;class T&#x3E;<br>
int f( T &#x26;&#x26;x )<br>
{<br>
&#x9;return y( x );<br>
} <br>
template &#x3C;class T&#x3E; int g( T &#x26;&#x26;x )<br>
{<br>
&#x9;return y( std::move( x ) );<br>
}<br>
template &#x3C;class T&#x3E;<br>
int h( T &#x26;&#x26;x )<br>
{<br>
&#x9;return y( std::forward&#x3C;T&#x3E;( x ) );<br>
} <br>
int main()<br>
{ <br>
&#x9;int i = 10; <br>
&#x9;std::cout &#x3C;&#x3C; f(i) &#x3C;&#x3C; f(20); <br>
&#x9;std::cout &#x3C;&#x3C; g(i) &#x3C;&#x3C; g(20); <br>
&#x9;std::cout &#x3C;&#x3C; h(i) &#x3C;&#x3C; h(20); <br>
&#x9;<br>
&#x9;return 0; <br>
}<br>
</pre>
]]>
	</Code>
	<Level value="Intermediate"/>
	<Hint>
The T&#x26;&#x26; in the the templated functions do not necessarily denote an rvalue reference, it depends on the type that is used to instantiate the template. If instantiated with an lvalue, it collapses to an lvalue reference, if instantiated with an rvalue, it collapses to an rvalue reference.
	</Hint>
	</Element>
	<Element reference_id="45">
	<Options>
		<option value="The program is guaranteed to output"/>
		<option value="The program has a compilation error"/>
		<option value="The program is unspecified/implementation defined"/>
		<option value="The program is undefined"/>
	</Options>
	<Explanation>
X takes a template template parameter[1], meaning that any template argument for X needs to itself take a template parameter. For instance, you cannot do X&#x3C;int&#x3E;, but you can do X&#x3C;Y&#x3E;, since Y itself is a template. There are two definitions of X, first the general template one, then the specialization X&#x3C;Y&#x3E;. Y is a normal template. Z is a template alias declaration, meaning that Z is now an alias for Y (think of template aliases as a &#x22;typedef for templates&#x22;). Now let&#x27;s look at main(): Defining a variable of type X&#x3C;Y&#x3E; uses that specialization (printing 2). But what happens when we use a template alias, as in X&#x3C;Z&#x3E;? Is the specialization X&#x3C;Y&#x3E; still used, since Z is an alias for Y? No. According to &#xA7;14.5.7&#xB6;1 in the standard, a template alias declaration resolve to a new family of types. The specialization cannot be used, and the first template delcaration is used instead, printing 1. [1]: For a good introduction to template template parameters, see http://www.informit.com/articles/article.aspx?p=376878
	</Explanation>
	<Question>
According to the C++11 standard, what is output of the following code?
	</Question>
	<Code>
<![CDATA[
<pre>
#include &#x3C;iostream&#x3E;<br>
template &#x3C;template &#x3C;typename&#x3E; class&#x3E;<br>
struct X<br>
{<br>
&#x9;X()<br>
&#x9;{<br>
&#x9;&#x9;std::cout &#x3C;&#x3C; &#x22;1&#x22;;<br>
&#x9;}<br>
}; <br>
template &#x3C;typename&#x3E;<br>
struct Y<br>
{<br>
}; <br>
template &#x3C;typename T&#x3E; <br>
using Z = Y&#x3C;T&#x3E;; <br>
template &#x3C;&#x3E; <br>
struct X&#x3C;Y&#x3E;<br>
{<br>
&#x9;X()<br>
&#x9;{<br>
&#x9;&#x9;std::cout &#x3C;&#x3C; &#x22;2&#x22;;<br>
&#x9;}<br>
}; <br>
int main()<br>
{<br>
&#x9;X&#x3C;Y&#x3E; x1;<br>
&#x9;X&#x3C;Z&#x3E; x2;<br>
}<br>
</pre>
]]>
	</Code>
	<Level value="Hard"/>
	<Hint>
Is a template alias a new family of types?
	</Hint>
	</Element>
	<Element reference_id="46">
	<Explanation>
Sneaky ambiguous function call. The statement print(0); is ambiguous due to overload resolution rules. Both print functions are viable, but for the compiler to pick one, one of them has to have a better conversion sequence than the other. &#xA7;13.3.3&#xB6;2: &#x22;If there is exactly one viable function that is a better function than all other viable functions, then it is the one selected by overload resolution; otherwise the call is ill-formed&#x22;. (a) Because 0 is a null pointer constant[1], it can be converted implicitly into any pointer type with a single conversion. (b) Because 0 is of type int, it can be converted implicitly to a short with a single conversion too. In our case, both are standard conversion sequences with a single conversion of &#x22;conversion rank&#x22;. Since no function is better than the other, the call is ill-formed. [1] &#xA7;4.10&#xB6;1 A null pointer constant is an integral constant expression (5.19) prvalue of integer type that evaluates to zero(...) A null pointer constant can be converted to a pointer type.
	</Explanation>
	<Hint>
Which type should 0 be converted to? Is one conversion better than the other?
	</Hint>
	<Question>
According to the C++11 standard, what is output of the following code?
	</Question>
	<Options>
		<option value="The program is guaranteed to output"/>
		<option value="The program has a compilation error"/>
		<option value="The program is unspecified/implementation defined"/>
		<option value="The program is undefined"/>
	</Options>
	<Code>
<![CDATA[
<pre>
#include &#x3C;iostream&#x3E; <br>
void print( char const *str )<br>
{ <br>
&#x9;std::cout &#x3C;&#x3C; str; <br>
} <br>
void print( short num )<br>
{<br>
&#x9;std::cout &#x3C;&#x3C; num;<br>
}<br>
int main()<br>
{<br>
&#x9;print( &#x22;abc&#x22; );<br>
&#x9;print( 0 ); <br>
&#x9;print( &#x27;A&#x27; );<br>
}<br>
</pre>
]]>
	</Code>
	<Level value="Beginner"/>
	</Element>
	<Element reference_id="47">
	<Explanation>
As defined in &#xA7;3.3.2&#xB6;1, the point of name declaration is after its complete declarator and before its initialisation. This means that line 4 is valid C++, because it&#x27;s possible to initialise the variable p with the address of an existing variable, even if it is its own address. The value of p is unknown, but can not be a null pointer value. The cast must thus evaluate to 1 and initialise the temporary bool as true.
	</Explanation>
	<Hint>
At which point in the program is the name p declared?
	</Hint>
	<Question>
According to the C++11 standard, what is output of the following code?
	</Question>
	<Options>
		<option value="The program is guaranteed to output"/>
		<option value="The program has a compilation error"/>
		<option value="The program is unspecified/implementation defined"/>
		<option value="The program is undefined"/>
	</Options>
	<Code>
<![CDATA[
<pre>
#include &#x3C;iostream&#x3E;<br>
int main()<br>
{<br>
&#x9;void * p = &#x26;p; <br>
&#x9;std::cout &#x3C;&#x3C; bool(p);<br>
}<br>
</pre>
]]>
	</Code>
	<Level value="Intermediate"/>
	</Element>
	<Element reference_id="48">
	<Explanation>
The comma operator has the lowest precedence of all C++ operators (specifically lower than =). In this example it separates the two expressions x = a and b. First x = a is evaluated, setting x to 10. Then, b is evaluated, which does nothing.
	</Explanation>
	<Hint>
Operator precedence.
	</Hint>
	<Question>
According to the C++11 standard, what is output of the following code?
	</Question>
	<Options>
		<option value="The program is guaranteed to output"/>
		<option value="The program has a compilation error"/>
		<option value="The program is unspecified/implementation defined"/>
		<option value="The program is undefined"/>
	</Options>
	<Code>
<![CDATA[
<pre>
#include &#x3C;iostream&#x3E; <br>
int main() <br>
{<br>
&#x9;int a = 10; <br>
&#x9;int b = 20;<br>
&#x9;<br>
&#x9;int x;<br>
&#x9;x = a, b; <br>
&#x9;<br>
&#x9;std::cout &#x3C;&#x3C; x; <br>
}<br>
</pre>
]]>
	</Code>
	<Level value="Beginner"/>
	</Element>
	<Element reference_id="49">
	<Explanation>
The comma operator is applied on two expressions: a and b. According to &#xA7;5.18&#xB6;10 in the standard: &#x22;A pair of expressions separated by a comma is evaluated left-to-right; the left expression is a discarded-value expression (...) The type and value of the result are the type and value of the right operand&#x22; The right operand here being b, with the value 20. This is then the resulting value of the expression (a, b), and 20 is assigned to x.
	</Explanation>
	<Hint>
What effect does parentheses have on operator precedence? What is the value of an expression involving the comma operator?
	</Hint>
	<Question>
According to the C++11 standard, what is output of the following code?
	</Question>
	<Options>
		<option value="The program is guaranteed to output"/>
		<option value="The program has a compilation error"/>
		<option value="The program is unspecified/implementation defined"/>
		<option value="The program is undefined"/>
		<option value=""/>
		<option value="#include &#x3C;iostream&#x3E; "/>
		<option value=""/>
		<option value="int main()"/>
		<option value="{"/>
		<option value="&#x9;int a = 10;"/>
		<option value="&#x9;int b = 20;"/>
		<option value="&#x9;int x; "/>
		<option value="&#x9;x = ( a, b );"/>
		<option value="&#x9;std::cout &#x3C;&#x3C; x;"/>
		<option value="}"/>
	</Options>
	<Code>
<![CDATA[
<pre>
</pre>
]]>
	</Code>
	<Level value="Intermediate"/>
	</Element>
	<Element reference_id="50">
	<Options>
		<option value="The program is guaranteed to output"/>
		<option value="The program has a compilation error"/>
		<option value="The program is unspecified/implementation defined"/>
		<option value="The program is undefined"/>
	</Options>
	<Explanation>
&#xA7;7.1&#xB6;2 in the C++11 standard states, &#x22;If a type-name is encountered while parsing a decl-speci?er-seq, it is interpreted as part of the decl-speci?er-seq if and only if there is no previous type-speci?er other than a cv-quali?er in the decl-speci?er-seq.&#x22; &#xA7;7.1&#xB6;3 also has a note: &#x22;Since signed, unsigned, long, and short by default imply int, a type-name appearing after one of those speci?ers is treated as the name being (re)declared.&#x22; In void foo(unsigned ll), since unsigned implies int, ll is being redeclared as a parameter name.
	</Explanation>
	<Question>
According to the C++11 standard, what is output of the following code?
	</Question>
	<Code>
<![CDATA[
<pre>
#include &#x3C;iostream&#x3E;<br>
typedef long long ll; <br>
void foo( unsigned ll )<br>
{<br>
&#x9;std::cout &#x3C;&#x3C; &#x22;1&#x22;;<br>
}<br>
void foo( unsigned long long )<br>
{<br>
&#x9;std::cout &#x3C;&#x3C; &#x22;2&#x22;;<br>
} <br>
int main() <br>
{<br>
&#x9;foo( 2ull );<br>
}<br>
</pre>
]]>
	</Code>
	<Level value="Hard"/>
	<Hint>
What does unsigned imply by default?
	</Hint>
	</Element>
	<Element reference_id="51">
	<Explanation>
The standard (&#xA7;14.1&#xB6;14) says: &#x22;A template-parameter of a template template-parameter is permitted to have a default template-argument. When such default arguments are specified, they apply to the template template-parameter in the scope of the template template-parameter.&#x22; In this case, the template template-parameter is C, and the scope of C is the function g(), so the default arguments of C (i.e. T = B) are applied and C&#x3C;B&#x3E;::f() is called inside g().
	</Explanation>
	<Hint>
What are the scopes of template parameters?
	</Hint>
	<Question>
According to the C++11 standard, what is output of the following code?
	</Question>
	<Options>
		<option value="The program is guaranteed to output"/>
		<option value="The program has a compilation error"/>
		<option value="The program is unspecified/implementation defined"/>
		<option value="The program is undefined"/>
	</Options>
	<Code>
<![CDATA[
<pre>
#include &#x3C;iostream&#x3E; <br>
using namespace std;<br>
struct A<br>
{<br>
};<br>
struct B<br>
{<br>
};<br>
template&#x3C;typename T = A&#x3E;<br>
struct X;<br>
template&#x3C;&#x3E; <br>
struct X&#x3C;A&#x3E;<br>
{<br>
&#x9;static void f()<br>
&#x9;{<br>
&#x9;&#x9;cout &#x3C;&#x3C; 1 &#x3C;&#x3C; endl;<br>
&#x9;}<br>
};<br>
template&#x3C;&#x3E;<br>
struct X&#x3C;B&#x3E;<br>
{<br>
&#x9;static void f()<br>
&#x9;{<br>
&#x9;&#x9;cout &#x3C;&#x3C; 2 &#x3C;&#x3C; endl;<br>
&#x9;}<br>
};<br>
template&#x3C; template&#x3C;typename T = B&#x3E; class C&#x3E; <br>
void g() <br>
{<br>
&#x9;C&#x3C;&#x3E;::f();<br>
}<br>
int main()<br>
{<br>
&#x9;g&#x3C;X&#x3E;();<br>
}<br>
</pre>
]]>
	</Code>
	<Level value="Hard"/>
	</Element>
	<Element reference_id="52">
	<Explanation>
&#xA7;14.8&#xB6;2: Each function template specialization instantiated from a template has its own copy of any static variable. This means we get two instantiations of f, one for T=int, and one for T=double. Thus, i is shared between the two int calls, but not with the double call.
	</Explanation>
	<Hint>
How many different instantiations of f will exist?
	</Hint>
	<Question>
According to the C++11 standard, what is output of the following code?
	</Question>
	<Options>
		<option value="The program is guaranteed to output"/>
		<option value="The program has a compilation error"/>
		<option value="The program is unspecified/implementation defined"/>
		<option value="The program is undefined"/>
	</Options>
	<Code>
<![CDATA[
<pre>
#include &#x3C;iostream&#x3E; <br>
using namespace std; <br>
template &#x3C;class T&#x3E;<br>
void f( T )<br>
{<br>
&#x9;static int i = 0;<br>
&#x9;cout &#x3C;&#x3C; ++i;<br>
}<br>
int main()<br>
{<br>
&#x9;f( 1 );<br>
&#x9;f( 1.0 );<br>
&#x9;f( 1 );<br>
}<br>
</pre>
]]>
	</Code>
	<Level value="Intermediate"/>
	</Element>
	<Element reference_id="53">
	<Explanation>
&#xA7;3.4&#xB6;14 states &#x22;&#x22;if a variable member of a namespace is defined outside of the scope of its namespace then any name that appears in the definition of the member after the declarator-id) is looked up as if the definition of the member occurred in its namespace...&#x22; Using the class scope to specify the static member x changes the initial lookup-path for foo(). The scope at which x exists(that is, the enclosing namepsace where x was declared) is first searched before considering the surrounding namespaces.
	</Explanation>
	<Hint>
This question is about the lookup-rules for foo in the definition of x. Will the global foo or the member foo be chosen? If you don&#x27;t know, think about some other scenarios for definition of class members, which scope would it make sense to have access to?
	</Hint>
	<Question>
According to the C++11 standard, what is output of the following code?
	</Question>
	<Options>
		<option value="The program is guaranteed to output"/>
		<option value="The program has a compilation error"/>
		<option value="The program is unspecified/implementation defined"/>
		<option value="The program is undefined"/>
	</Options>
	<Code>
<![CDATA[
<pre>
#include&#x3C;iostream&#x3E;<br>
int foo()<br>
{<br>
&#x9;return 10;<br>
}<br>
struct foobar<br>
{<br>
&#x9;static int x;<br>
&#x9;static int foo() <br>
&#x9;{<br>
&#x9;&#x9;return 11; <br>
&#x9;}<br>
}; <br>
int foobar::x = foo();<br>
int main()<br>
{<br>
&#x9;std::cout &#x3C;&#x3C; foobar::x;<br>
}<br>
</pre>
]]>
	</Code>
	<Level value="Intermediate"/>
	</Element>
	<Element reference_id="54">
	<Explanation>
&#xA7;5.1.2&#xB6;18 says Every occurrence of decltype((x)) where x is a possibly parenthesized id-expression that names an entity of automatic storage duration is treated as if x were transformed into an access to a corresponding data member of the closure type that would have been declared if x were an odr-use of the denoted entity. So additional parentheses, as the in the code snippet above, are ignored. The member of the closure type corresponding to the as-if-captured j will be not a reference, but will have the referenced type of the reference, since it is captured by copy (&#xA7;5.1.2&#xB6;14). Since the lambda is not declared mutable, the overloaded operator() of the closure type will be a const member function. 5.1.2&#xB6;5: &#x22;The closure type for a lambda-expression has a public inline function call operator (...) This function call operator is declared const if and only if the lambda-expression&#x2019;s parameter-declaration-clause is not followed by mutable.&#x22; Since the expression for decltype is a parenthesized lvalue expression, &#xA7;7.1.6.2&#xB6;4 has this to say: &#x22;The type denoted by decltype(e) is (...) T&#x26;, where T is the type of e;&#x22; As the expression occurs inside a const member function, the expression is const, and decltype((j)) denotes int const&#x26;. See also the example in &#xA7;5.1.2&#xB6;18.
	</Explanation>
	<Hint>
[=] captures by copy. There&#x27;s an important difference between decltype(j) and decltype((j)). What is the const-ness of the lambda&#x27;s operator()?
	</Hint>
	<Question>
According to the C++11 standard, what is output of the following code?
	</Question>
	<Options>
		<option value="The program is guaranteed to output"/>
		<option value="The program has a compilation error"/>
		<option value="The program is unspecified/implementation defined"/>
		<option value="The program is undefined"/>
	</Options>
	<Code>
<![CDATA[
<pre>
#include &#x3C;iostream&#x3E;<br>
#include &#x3C;type_traits&#x3E; <br>
using namespace std;<br>
int main()<br>
{<br>
&#x9;int i, &#x26;j = i; <br>
&#x9;[=]{<br>
&#x9;&#x9;cout &#x3C;&#x3C; is_same&#x3C;decltype ((j)), int &#x3E;::value<br>
&#x9;&#x9;&#x3C;&#x3C; is_same&#x3C;decltype (((j))), int &#x26; &#x3E;::value &#x3C;&#x3C; is_same&#x3C;decltype ((((j)))), int const&#x26; &#x3E;::value <br>
&#x9;&#x9;&#x3C;&#x3C; is_same&#x3C;decltype (((((j))))), int &#x26;&#x26; &#x3E;::value &#x3C;&#x3C; is_same&#x3C;decltype((((((j)))))), int const&#x26;&#x26; &#x3E;::value;<br>
&#x9;}();<br>
}<br>
</pre>
]]>
	</Code>
	<Level value="Hard"/>
	</Element>
	<Element reference_id="55">
	<Explanation>
Here we are trying to initialize a vector&#x3C;char&#x3E; using two string literals, not two chars. The initializer-list constructor for template &#x3C;class T&#x3E;vector is defined as vector(initializer_list&#x3C;T&#x3E;) by &#xA7;23.3.6.1 in the standard. In our case, vector(initializer_list&#x3C;char&#x3E;). The type of a string literal is &#x22;array of n const char&#x22; (&#xA7;2.14.5&#xB6;8), so clearly the initializer-list constructor is not a match. This problem does however not result in a compiler error, since the compiler is able to find another constructor that matches! &#xA7;13.3.1.7&#xB6;1 explains the rules very clearly: &#x22;When objects of non-aggregate class type T are list-initialized, overload resolution selects the constructor in two phases: &#x2014; Initially, the candidate functions are the initializer-list constructors of the class T and the argument list consists of the initializer list as a single argument [which we have seen didn&#x27;t match]. &#x2014; If no viable initializer-list constructor is found, overload resolution is performed again, where the candidate functions are all the constructors of the class T and the argument list consists of the elements of the initializer list [in our case, the two string literals &#x22;,&#x22; and &#x22;;&#x22; ]&#x22;. Going back to &#xA7;23.3.6.1, we find this candidate: template &#x3C;class InputIterator&#x3E; vector(InputIterator first, InputIterator last) Note that the type of InputIterator has no link to the type of T in the vector&#x3C;T&#x3E;. So even if we are initializing a vector&#x3C;char&#x3E;, the two arguments can be of arbitrary type. The only requirement is that they confirm to the concept of InputIterator, which const char[] happens to do. Now the constructor believes it has been passed two iterators to the same sequence, but it has actually been passed iterators to two completely different sequences, &#x22;,&#x22; and &#x22;;&#x22;. &#xA7;24.2.5&#xB6;2 says: &#x22;The domain of == for forward iterators is that of iterators over the same underlying sequence.&#x22;. So the result of this program is undefined.
	</Explanation>
	<Hint>
The type of &#x22;,&#x22; is const char[], not char.
	</Hint>
	<Question>
According to the C++11 standard, what is output of the following code?
	</Question>
	<Options>
		<option value="The program is guaranteed to output"/>
		<option value="The program has a compilation error"/>
		<option value="The program is unspecified/implementation defined"/>
		<option value="The program is undefined"/>
	</Options>
	<Code>
<![CDATA[
<pre>
#include &#x3C;vector&#x3E;<br>
#include &#x3C;iostream&#x3E; <br>
using namespace std; <br>
int main()<br>
{<br>
&#x9;std::vector&#x3C;char&#x3E; delimiters = { &#x22;,&#x22;, &#x22;;&#x22; };<br>
&#x9;cout &#x3C;&#x3C; delimiters[0];<br>
}<br>
</pre>
]]>
	</Code>
	<Level value="Intermediate"/>
	</Element>
	<Element reference_id="56">
	<Explanation>
&#xA7;14.6&#xB6;9 states: &#x22;When looking for the declaration of a name used in a template definition, the usual lookup rules (&#xA7;3.4.1, &#xA7;3.4.2) are used for non-dependent names. The lookup of names dependent on the template parameters is postponed until the actual template argument is known (&#xA7;14.6.2).&#x22; The first call to adl is a non-dependent call, so it is looked up at the time of definition of the function template. The resolution of the second call is deferred until the template is instantiated because it depends on a template parameter.     template&#x3C;typename T&#x3E; void call_adl_function(T t)     {         adl(S()); // Independent, looks up adl now.         adl(t); // Dependent, looks up adl later.     } When adl is being looked up at the time of definition of the function template, the only version of adl that exists is the templated adl(T). Specifically, adl(S) does not exist yet, and is not a candidate. Note: At the time of writing, this program does not confirm to the standard in some recent versions of Visual Studio&#x27;s C++ compiler.
	</Explanation>
	<Hint>
Unqualified names are resolved at different times depending on whether they are dependent or independent on a template parameter.
	</Hint>
	<Question>
According to the C++11 standard, what is output of the following code?
	</Question>
	<Options>
		<option value="The program is guaranteed to output"/>
		<option value="The program has a compilation error"/>
		<option value="The program is unspecified/implementation defined"/>
		<option value="The program is undefined"/>
	</Options>
	<Code>
<![CDATA[
<pre>
#include &#x3C;iostream&#x3E;<br>
using namespace std;<br>
template&#x3C;typename T&#x3E; <br>
void adl( T )<br>
{<br>
&#x9;cout &#x3C;&#x3C; &#x22;T&#x22;;<br>
}<br>
struct S<br>
{<br>
}; <br>
template&#x3C;typename T&#x3E; <br>
void call_adl( T t )<br>
{<br>
&#x9;adl( S() );<br>
&#x9;adl( t ); <br>
} <br>
void adl( S )<br>
{<br>
&#x9;cout &#x3C;&#x3C; &#x22;S&#x22;;<br>
}<br>
int main()<br>
{<br>
&#x9;call_adl( S() );<br>
}<br>
</pre>
]]>
	</Code>
	<Level value="Hard"/>
	</Element>
	<Element reference_id="57">
	<Explanation>
These are two examples of initialization. The first form, C c1(7), is called direct-initialization, the second, C c2 = 7, is called copy-initialization. In most cases they are equivalent, but in this example they are not, since the int constructor is explicit. They key is in 12.3.1&#xB6;2 : &#x22;An explicit constructor constructs objects just like non-explicit constructors, but does so only where the direct-initialization syntax (8.5) or where casts (5.2.9, 5.4) are explicitly used.&#x22; And how is direct-initialization defined? 8.5&#xB6;15: &#x22;The initialization that occurs in the forms T x(a); T x{a}; (...) is called direct-initialization.&#x22; So the int constructor is not even considered for initialization in the second case. Instead, a standard conversion sequence is used to convert the integer literal to a double, and the double constructor (the only candidate) is used.
	</Explanation>
	<Options>
		<option value="The program is guaranteed to output"/>
		<option value="The program has a compilation error"/>
		<option value="The program is unspecified/implementation defined"/>
		<option value="The program is undefined"/>
	</Options>
	<Question>
According to the C++11 standard, what is output of the following code?
	</Question>
	<Code>
<![CDATA[
<pre>
#include &#x3C;iostream&#x3E; <br>
using namespace std; <br>
class C<br>
{<br>
public: <br>
&#x9;explicit C( int )<br>
&#x9;{<br>
&#x9;&#x9;std::cout &#x3C;&#x3C; &#x22;i&#x22;;<br>
&#x9;};<br>
&#x9;C( double )<br>
&#x9;{<br>
&#x9;&#x9;std::cout &#x3C;&#x3C; &#x22;d&#x22;; <br>
&#x9;};<br>
};<br>
int main()<br>
{<br>
&#x9;C c1( 7 );<br>
&#x9;C c2 = 7;<br>
}<br>
</pre>
]]>
	</Code>
	<Level value="Intermediate"/>
	<Hint>
How well does explicit constructors and copy-initialization play along?
	</Hint>
	</Element>
	<Element reference_id="58">
	<Explanation>
Is foo called both times or just once? The C++11 standard says this in &#xA7;8.3.6&#xB6;9: &#x22;Default arguments are evaluated each time the function is called.&#x22; Thus, foo is called twice.
	</Explanation>
	<Hint>
When are default arguments evaluated?
	</Hint>
	<Question>
According to the C++11 standard, what is output of the following code?
	</Question>
	<Options>
		<option value="The program is guaranteed to output"/>
		<option value="The program has a compilation error"/>
		<option value="The program is unspecified/implementation defined"/>
		<option value="The program is undefined"/>
	</Options>
	<Code>
<![CDATA[
<pre>
#include &#x3C;iostream&#x3E;<br>
using namespace std;<br>
int foo()<br>
{<br>
&#x9;cout &#x3C;&#x3C; 1; <br>
&#x9;return 1;<br>
}<br>
void bar( int i = foo() )<br>
{<br>
}<br>
int main()<br>
{<br>
&#x9;bar();<br>
&#x9;bar();<br>
}<br>
</pre>
]]>
	</Code>
	<Level value="Beginner"/>
	</Element>
	<Element reference_id="59">
	<Explanation>
On the first line of main(), d1 is initialized, in the order A, B, C, D. That order is defined by &#xA7;12.6.2&#xB6;10: &#x22; &#x2014; First, and only for the constructor of the most derived class (1.8), virtual base classes are initialized in the order they appear on a depth-first left-to-right traversal of the directed acyclic graph of base classes, where &#x201C;left-to-right&#x201D; is the order of appearance of the base classes in the derived class base-specifier-list. &#x2014; Then, direct base classes are initialized in declaration order as they appear in the base-specifier-list (...) &#x2014; Finally, the compound-statement of the constructor body is executed. &#x22; So the output is ABCD. On the second line, d2 is initialized. But why are the constructors (as opposed to the copy constructors) for the base classes, called? Why do we see ABCd instead of abcd? As it turns out, an implicitly-defined copy constructor would have called the copy constructor of its bases (&#xA7;12.8&#xB6;.15: &#x22;The implicitly-defined copy/move constructor for a non-union class X performs a memberwise copy/move of its bases and members.&#x22;). But when you provide a user-defined copy constructor, this is something you have to do explicitly.
	</Explanation>
	<Hint>
Virtual inheritance is a technique used to avoid multiple copies of the same indirect base class in an object. The call order of base constructors is well defined.
	</Hint>
	<Question>
According to the C++11 standard, what is output of the following code?
	</Question>
	<Options>
		<option value="The program is guaranteed to output"/>
		<option value="The program has a compilation error"/>
		<option value="The program is unspecified/implementation defined"/>
		<option value="The program is undefined"/>
	</Options>
	<Code>
<![CDATA[
<pre>
#include &#x3C;iostream&#x3E;<br>
using namespace std;<br>
class A<br>
{<br>
public:<br>
&#x9;A()<br>
&#x9;{<br>
&#x9;&#x9;cout &#x3C;&#x3C; &#x22;A&#x22;;<br>
&#x9;}<br>
&#x9;A( const A &#x26; )<br>
&#x9;{<br>
&#x9;&#x9;cout &#x3C;&#x3C; &#x22;a&#x22;; <br>
&#x9;}<br>
}; <br>
class B: virtual A <br>
{<br>
public:<br>
&#x9;B()<br>
&#x9;{ <br>
&#x9;&#x9;cout &#x3C;&#x3C; &#x22;B&#x22;; <br>
&#x9;}<br>
&#x9;B( const B &#x26; )<br>
&#x9;{ <br>
&#x9;&#x9;cout&#x3C;&#x3C; &#x22;b&#x22;;<br>
&#x9;}<br>
}; <br>
class C: virtual A <br>
{<br>
public: <br>
&#x9;C() <br>
&#x9;{<br>
&#x9;&#x9;cout&#x3C;&#x3C; &#x22;C&#x22;; <br>
&#x9;} <br>
&#x9;C( const C &#x26; )<br>
&#x9;{<br>
&#x9;&#x9;cout &#x3C;&#x3C; &#x22;c&#x22;; <br>
&#x9;}<br>
}; <br>
class D: B, C <br>
{<br>
public: <br>
&#x9;D() <br>
&#x9;{ <br>
&#x9;&#x9;cout&#x3C;&#x3C; &#x22;D&#x22;;<br>
&#x9;} <br>
&#x9;D( const D &#x26; )<br>
&#x9;{ <br>
&#x9;&#x9;cout &#x3C;&#x3C; &#x22;d&#x22;; <br>
&#x9;} <br>
};<br>
int main()<br>
{<br>
&#x9;D d1;<br>
&#x9;D d2( d1 ); <br>
}<br>
</pre>
]]>
	</Code>
	<Level value="Intermediate"/>
	</Element>
	<Element reference_id="60">
	<Explanation>
std::map stores values based on a unique key. The keys for mb are boolean, and 1, 3 and 5 all evaluate to the same key, true. &#xA7;23.4.4.1&#xB6;1 in the standard: &#x22;A map is an associative container that supports unique keys (contains at most one of each key value).&#x22; The type of mb is map&#x3C;bool,int&#x3E;. The key is bool, so the integers 1, 3 and 5 used for initialization are first converted to bool, and they all evaluate to true. &#xA7;4.12&#xB6;1 in the standard: &#x22;A prvalue of arithmetic, unscoped enumeration, pointer, or pointer to member type can be converted to a prvalue of type bool. A zero value, null pointer value, or null member pointer value is converted to false; any other value is converted to true.&#x22;
	</Explanation>
	<Hint>
What is the type of mb?
	</Hint>
	<Question>
According to the C++11 standard, what is output of the following code?
	</Question>
	<Options>
		<option value="The program is guaranteed to output"/>
		<option value="The program has a compilation error"/>
		<option value="The program is unspecified/implementation defined"/>
		<option value="The program is undefined"/>
	</Options>
	<Code>
<![CDATA[
<pre>
#include &#x3C;iostream&#x3E;<br>
#include &#x3C;map&#x3E;<br>
using namespace std;<br>
int main()<br>
{<br>
&#x9;map&#x3C;bool,int&#x3E; mb = { { 1, 2 }, { 3, 4 }, { 5,0 } };<br>
&#x9;cout &#x3C;&#x3C; mb.size(); <br>
&#x9;map&#x3C;int,int&#x3E; mi = { { 1, 2 },{ 3, 4 },{ 5, 0 } };<br>
&#x9;cout &#x3C;&#x3C; mi.size(); <br>
}<br>
</pre>
]]>
	</Code>
	<Level value="Beginner"/>
	</Element>
	<Element reference_id="61">
	<Explanation>
This question compares three ways for a function to take an array as parameter, while two of them are actually the same. In main, the array is of array type, therefore the sizeof operator returns the size of the array in terms of bytes. (&#xA7;5.3.3&#xB6;2 in the standard: &#x22;When applied to an array, the result [of the sizeof operator] is the total number of bytes in the array. This implies that the size of an array of n elements is n times the size of an element.&#x22;) In get_size_3, the parameter is a reference to an array of size 10, therefore the sizeof operator returns the size of the array in terms of bytes. (&#xA7;5.3.3&#xB6;2 in the standard: When applied to a reference or a reference type, the result is the size of the referenced type. ) In get_size_1 and get_size_2, the parameter is a pointer, therefore the sizeof operator returns the size of the pointer. Although the parameter of get_size_2 is an array, it is adjusted into a pointer. (&#xA7;8.3.5&#xB6;5 in the standard: &#x22;any parameter of type &#x201C;array of T&#x201D; (...) is adjusted to be &#x201C;pointer to T&#x201D;&#x22; )
	</Explanation>
	<Options>
		<option value="The program is guaranteed to output"/>
		<option value="The program has a compilation error"/>
		<option value="The program is unspecified/implementation defined"/>
		<option value="The program is undefined"/>
	</Options>
	<Question>
According to the C++11 standard, what is output of the following code?
	</Question>
	<Code>
<![CDATA[
<pre>
#include &#x3C;iostream&#x3E; <br>
using namespace std; <br>
size_t get_size_1( int* arr )<br>
{<br>
&#x9;return sizeof arr; <br>
}<br>
size_t get_size_2( int arr[] )<br>
{<br>
&#x9;return sizeof arr; <br>
} <br>
size_t get_size_3( int ( &#x26;arr )[10] )<br>
{<br>
&#x9;return sizeof arr; <br>
} <br>
int main()<br>
{ <br>
&#x9;int array[10]; <br>
&#x9;cout &#x3C;&#x3C; ( sizeof( array ) == get_size_1( array ) );<br>
&#x9;cout &#x3C;&#x3C; ( sizeof( array ) == get_size_2( array ) );<br>
&#x9;cout &#x3C;&#x3C; ( sizeof( array ) == get_size_3( array ) ); <br>
}<br>
</pre>
]]>
	</Code>
	<Level value="Intermediate"/>
	<Hint>
&#xA7;8.3.5&#xB6;5 in the standard: &#x22;any parameter of type &#x201C;array of T&#x201D; (...) is adjusted to be &#x201C;pointer to T&#x201D;&#x22;
	</Hint>
	</Element>
	<Element reference_id="62">
	<Options>
		<option value="The program is guaranteed to output"/>
		<option value="The program has a compilation error"/>
		<option value="The program is unspecified/implementation defined"/>
		<option value="The program is undefined"/>
	</Options>
	<Explanation>
As the else part of the branch is obvious, we concentrate on the if part and make the assumptions present in the condition. &#xA7;2.14.2 in the standard: &#x22;The type of an integer literal is the first of the corresponding list in Table 6.&#x22; [Table 6: int, unsigned int, long int, unsigned long int &#x2026; for hexadecimal literals --end Table] in which its value can be represented.&#x22; Since the literal 0xffffffff needs 32 digits, it can be represented as an unsigned int but not as a signed int, and is of type unsigned int. But what happens with the negative of an unsigned integer? &#xA7;5.3.1 in the standard: &#x22;The negative of an unsigned quantity is computed by subtracting its value from 2^n , where n is the number of bits in the promoted operand.&#x22; Here n is 32, and we get: 2^32 - 0xffffffff = 4294967296 - 4294967295 = 1 So i is initialised to 1, and N[1] is the only element accessed in the loop. (The second time around the loop, i is 0, which evaluates to false, and the loop terminates.)
	</Explanation>
	<Question>
According to the C++11 standard, what is output of the following code?
	</Question>
	<Code>
<![CDATA[
<pre>
#include &#x3C;iostream&#x3E;<br>
#include &#x3C;limits&#x3E;<br>
int main()<br>
{<br>
&#x9;int N[] = { 0, 0, 0 };<br>
&#x9;if( std::numeric_limits&#x3C;long int&#x3E;::digits == 63 <br>
&#x9;&#x9;and std::numeric_limits&#x3C;int&#x3E;::digits == 31<br>
&#x9;&#x9;and std::numeric_limits&#x3C;unsigned int&#x3E;::digits == 32 )<br>
&#x9;{<br>
&#x9;&#x9;for( long int i = -0xffffffff; i ; --i )<br>
&#x9;&#x9;{<br>
&#x9;&#x9;&#x9;N[i] = 1; <br>
&#x9;&#x9;}<br>
&#x9;} <br>
&#x9;else<br>
&#x9;{ <br>
&#x9;&#x9;N[1] = 1;<br>
&#x9;}<br>
&#x9;std::cout &#x3C;&#x3C; N[0] &#x3C;&#x3C;N [1] &#x3C;&#x3C; N[2];<br>
}<br>
</pre>
]]>
	</Code>
	<Level value="Hard"/>
	<Hint>
What will be the type of the integer literal?
	</Hint>
	</Element>
	<Element reference_id="63">
	<Options>
		<option value="The program is guaranteed to output"/>
		<option value="The program has a compilation error"/>
		<option value="The program is unspecified/implementation defined"/>
		<option value="The program is undefined"/>
	</Options>
	<Explanation>
In f(), an E object is constructed, and 1 is printed. This object is then returned to main(), and one could expect the copy constructor to be called, printing 2. However, &#xA7;6.6.3&#xB6;2 in the standard says &#x22;Note: A copy or move operation associated with a return statement may be elided&#x22;, meaning that the implementation is free to skip the copy constructor. This is optional, and unspecified behaviour. Most implementations will elide the copy constructor and output 13, but may be urged not to so with the -fno-elide-constructors option and output 1233. For more information about the return value optimisation, and an investigation of which implementations use it, see http://blog.knatten.org/2011/08/26/dont-be-afraid-of-returning-by-value-know-the-return-value-optimization/
	</Explanation>
	<Question>
According to the C++11 standard, what is output of the following code?
	</Question>
	<Code>
<![CDATA[
<pre>
#include &#x3C;iostream&#x3E;<br>
struct E<br>
{<br>
&#x9;E()<br>
&#x9;{<br>
&#x9;&#x9;std::cout &#x3C;&#x3C; &#x22;1&#x22;;<br>
&#x9;}<br>
&#x9;E( const E&#x26; )<br>
&#x9;{<br>
&#x9;&#x9;std::cout &#x3C;&#x3C; &#x22;2&#x22;;<br>
&#x9;}<br>
&#x9;~E()<br>
&#x9;{<br>
&#x9;&#x9;std::cout &#x3C;&#x3C; &#x22;3&#x22;;<br>
&#x9;}<br>
}; <br>
E f()<br>
{<br>
&#x9;return E();<br>
} <br>
int main()<br>
{<br>
&#x9;f();<br>
}<br>
</pre>
]]>
	</Code>
	<Level value="Intermediate"/>
	<Hint>
Do you know the return value optimisation?
	</Hint>
	</Element>
	<Element reference_id="64">
	<Explanation>
??/ is a trigraph. According to &#xA7;2.4&#xB6;1, this trigraph is translated to \ before any other processing takes place. Since that \ is followed by a newline, the line x=1 is treated as a continuation of the comment. Note: Trigraphs will be removed from the standard in C++17.
	</Explanation>
	<Hint>
??/ is a trigraph translating to \.
	</Hint>
	<Question>
According to the C++11 standard, what is output of the following code?
	</Question>
	<Options>
		<option value="The program is guaranteed to output"/>
		<option value="The program has a compilation error"/>
		<option value="The program is unspecified/implementation defined"/>
		<option value="The program is undefined"/>
	</Options>
	<Code>
<![CDATA[
<pre>
#include&#x3C;iostream&#x3E; <br>
int main()<br>
{<br>
&#x9;int x = 0; // What is wrong here??/<br>
&#x9;x = 1;<br>
&#x9;std::cout &#x3C;&#x3C; x;<br>
}<br>
</pre>
]]>
	</Code>
	<Level value="Hard"/>
	</Element>
	<Element reference_id="65">
	<Explanation>
The issue here is not the missing initializer of the variable a - it will implicitly be initialized to 0 here. But the issue is the access to a twice without sequencing between the accesses. According to &#xA7;1.9&#xB6;12, accesses of volatile glvalues are side-effects and according to &#xA7;1.9&#xB6;15 these two unsequenced side-effects on the same scalar object result in undefined behavior.
	</Explanation>
	<Hint>
Accessing volatiles counts as a side effect.
	</Hint>
	<Question>
According to the C++11 standard, what is output of the following code?
	</Question>
	<Options>
		<option value="The program is guaranteed to output"/>
		<option value="The program has a compilation error"/>
		<option value="The program is unspecified/implementation defined"/>
		<option value="The program is undefined"/>
	</Options>
	<Code>
<![CDATA[
<pre>
#include &#x3C;iostream&#x3E;<br>
volatile int a; <br>
int main()<br>
{<br>
&#x9;std::cout &#x3C;&#x3C; ( a + a );<br>
}<br>
</pre>
]]>
	</Code>
	<Level value="Hard"/>
	</Element>
	<Element reference_id="66">
	<Options>
		<option value="The program is guaranteed to output"/>
		<option value="The program has a compilation error"/>
		<option value="The program is unspecified/implementation defined"/>
		<option value="The program is undefined"/>
	</Options>
	<Explanation>
&#xA7;3.9.1&#xB6;1 It is implementation-defined whether a char object can hold negative values.
	</Explanation>
	<Question>
According to the C++11 standard, what is output of the following code?
	</Question>
	<Code>
<![CDATA[
<pre>
#include &#x3C;iostream&#x3E;<br>
#include &#x3C;type_traits&#x3E; <br>
int main()<br>
{ <br>
&#x9;std::cout &#x3C;&#x3C; std::is_signed&#x3C;char&#x3E;::value;<br>
}<br>
</pre>
]]>
	</Code>
	<Level value="Intermediate"/>
	<Hint>
Plain char, signed char, and unsigned char are three distinct types.
	</Hint>
	</Element>
	<Element reference_id="67">
	<Explanation>
&#xA7;3.9.1&#xB6;1 Plain char, signed char, and unsigned char are three distinct types
	</Explanation>
	<Hint>
No hint
	</Hint>
	<Question>
According to the C++11 standard, what is output of the following code?
	</Question>
	<Options>
		<option value="The program is guaranteed to output"/>
		<option value="The program has a compilation error"/>
		<option value="The program is unspecified/implementation defined"/>
		<option value="The program is undefined"/>
	</Options>
	<Code>
<![CDATA[
<pre>
#include &#x3C;iostream&#x3E;<br>
#include &#x3C;type_traits&#x3E; <br>
int main()<br>
{<br>
&#x9;if( std::is_signed&#x3C;char&#x3E;::value )<br>
&#x9;{ <br>
&#x9;&#x9;std::cout &#x3C;&#x3C; std::is_same&#x3C;char, signed char&#x3E;::value;<br>
&#x9;}<br>
&#x9;else<br>
&#x9;{<br>
&#x9;&#x9;std::cout &#x3C;&#x3C; std::is_same&#x3C;char, unsigned char&#x3E;::value;<br>
&#x9;}<br>
}<br>
</pre>
]]>
	</Code>
	<Level value="Intermediate"/>
	</Element>
	<Element reference_id="68">
	<Explanation>
According to &#xA7;2.14.5&#xB6;8 in the standard: &#x22;A narrow string literal has type &#x201C;array of n const char&#x201D;&#x22; An array of n const char converts to a pointer to const char. According to &#xA7;4.4&#xB6;1: &#x22;A prvalue of type &#x201C;pointer to cv1 T&#x201D; can be converted to a prvalue of type &#x201C;pointer to cv2 T&#x201D; if &#x201C;cv2 T&#x201D; is more cv-qualified than &#x201C;cv1 T&#x201D;.&#x22; In this case however, char* is less cv-qualified than const char *, and the conversion is not allowed. Note: While most compilers still allow char const[] to char* conversion with just a warning, this is not a legal conversion in C++11. See also http://dev.krzaq.cc/stop-assigning-string-literals-to-char-star-already/
	</Explanation>
	<Hint>
What is the type of a string literal?
	</Hint>
	<Question>
According to the C++11 standard, what is output of the following code?
	</Question>
	<Options>
		<option value="The program is guaranteed to output"/>
		<option value="The program has a compilation error"/>
		<option value="The program is unspecified/implementation defined"/>
		<option value="The program is undefined"/>
	</Options>
	<Code>
<![CDATA[
<pre>
#include &#x3C;iostream&#x3E; <br>
int main()<br>
{<br>
&#x9;char* str = &#x22;X&#x22;;<br>
&#x9;std::cout &#x3C;&#x3C; str;<br>
}<br>
</pre>
]]>
	</Code>
	<Level value="Intermediate"/>
	</Element>
	<Element reference_id="69">
	<Explanation>
&#xA7;5.2.8&#xB6;1: &#x22;The result of a typeid expression is an lvalue of static type const std::type_info&#x22;, and &#xA7;5.3.1&#xB6;3: &#x22;The result of the unary &#x26; operator is a pointer to its operand&#x22;, so we&#x27;re comparing two pointers to const std::type_info. There is no guarantee that the same std::type_info instance will be referred to by all evaluations of the typeid expression on the same type, although std::type_info::hash_code of those type_info objects would be identical, as would be their std::type_index. (For more info on hash_code(), see &#xA7;18.7.1&#xB6;7 : &#x22;hash_code() (...)shall return the same value for any two type_info objects which compare equal&#x22;) (For more info on type_index equality, see &#xA7;20.13.3 and &#xA7;18.7.1)
	</Explanation>
	<Hint>
1. What is the value category of typeid result? 
2. Does all typeid( A ) refer the same object?
	</Hint>
	<Question>
According to the C++11 standard, what is output of the following code?
	</Question>
	<Options>
		<option value="The program is guaranteed to output"/>
		<option value="The program has a compilation error"/>
		<option value="The program is unspecified/implementation defined"/>
		<option value="The program is undefined"/>
	</Options>
	<Code>
<![CDATA[
<pre>
#include &#x3C;iostream&#x3E; <br>
#include &#x3C;typeinfo&#x3E; <br>
struct A <br>
{<br>
}; <br>
int main()<br>
{<br>
&#x9;std::cout&#x3C;&#x3C; ( &#x26;typeid( A ) == &#x26;typeid( A ));<br>
}<br>
</pre>
]]>
	</Code>
	<Level value="Intermediate"/>
	</Element>
	<Element reference_id="70">
	<Explanation>
Since C++11 (&#xA7;23.3.6.2&#xB6;3 in the standard), std::vector has a one parameter constructor explicit vector( size_type n ) which constructs a vector with n value-initialized elements. Each value-initialization calls the default Foo constructor, resulting in the output aaaaa . The &#x22;trick&#x22; is, that before C++11, std::vector had a 2 parameter constructor ( + allocator ), which constructed the container with n copies of the second parameter, which is defaulted to T(). So this code before C++11 would output abbbbb, because the call would be equivalent to std::vector&#x3C;Foo&#x3E; bar(5,T()).
	</Explanation>
	<Hint>
Which vector constructor will be called?
	</Hint>
	<Question>
According to the C++11 standard, what is output of the following code?
	</Question>
	<Options>
		<option value="The program is guaranteed to output"/>
		<option value="The program has a compilation error"/>
		<option value="The program is unspecified/implementation defined"/>
		<option value="The program is undefined"/>
	</Options>
	<Code>
<![CDATA[
<pre>
#include &#x3C;iostream&#x3E;<br>
#include &#x3C;vector&#x3E; <br>
struct Foo<br>
{ <br>
&#x9;Foo() <br>
&#x9;{ <br>
&#x9;&#x9;std::cout &#x3C;&#x3C; &#x22;a&#x22;;<br>
&#x9;} <br>
&#x9;Foo( const Foo&#x26; )<br>
&#x9;{ <br>
&#x9;&#x9;std::cout &#x3C;&#x3C; &#x22;b&#x22;;<br>
&#x9;}<br>
}; <br>
int main()<br>
{<br>
&#x9;std::vector&#x3C;Foo&#x3E; bar( 5 );<br>
}<br>
</pre>
]]>
	</Code>
	<Level value="Beginner"/>
	</Element>
</Root>
